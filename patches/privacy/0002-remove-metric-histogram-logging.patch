--- a/base/metrics/histogram_functions.cc
+++ b/base/metrics/histogram_functions.cc
@@ -12,39 +12,23 @@
 namespace base {
 
 void UmaHistogramBoolean(const std::string& name, bool sample) {
-  HistogramBase* histogram = BooleanHistogram::FactoryGet(
-      name, HistogramBase::kUmaTargetedHistogramFlag);
-  histogram->Add(sample);
 }
 
 void UmaHistogramBoolean(const char* name, bool sample) {
-  HistogramBase* histogram = BooleanHistogram::FactoryGet(
-      name, HistogramBase::kUmaTargetedHistogramFlag);
-  histogram->Add(sample);
 }
 
 void UmaHistogramExactLinear(const std::string& name,
                              int sample,
                              int value_max) {
-  HistogramBase* histogram =
-      LinearHistogram::FactoryGet(name, 1, value_max, value_max + 1,
-                                  HistogramBase::kUmaTargetedHistogramFlag);
-  histogram->Add(sample);
 }
 
 void UmaHistogramExactLinear(const char* name, int sample, int value_max) {
-  HistogramBase* histogram =
-      LinearHistogram::FactoryGet(name, 1, value_max, value_max + 1,
-                                  HistogramBase::kUmaTargetedHistogramFlag);
-  histogram->Add(sample);
 }
 
 void UmaHistogramPercentage(const std::string& name, int percent) {
-  UmaHistogramExactLinear(name, percent, 100);
 }
 
 void UmaHistogramPercentage(const char* name, int percent) {
-  UmaHistogramExactLinear(name, percent, 100);
 }
 
 void UmaHistogramCustomCounts(const std::string& name,
@@ -52,9 +36,6 @@ void UmaHistogramCustomCounts(const std:
                               int min,
                               int max,
                               int buckets) {
-  HistogramBase* histogram = Histogram::FactoryGet(
-      name, min, max, buckets, HistogramBase::kUmaTargetedHistogramFlag);
-  histogram->Add(sample);
 }
 
 void UmaHistogramCustomCounts(const char* name,
@@ -62,9 +43,6 @@ void UmaHistogramCustomCounts(const char
                               int min,
                               int max,
                               int buckets) {
-  HistogramBase* histogram = Histogram::FactoryGet(
-      name, min, max, buckets, HistogramBase::kUmaTargetedHistogramFlag);
-  histogram->Add(sample);
 }
 
 void UmaHistogramCounts100(const std::string& name, int sample) {
@@ -120,9 +98,6 @@ void UmaHistogramCustomTimes(const std::
                              TimeDelta min,
                              TimeDelta max,
                              int buckets) {
-  HistogramBase* histogram = Histogram::FactoryTimeGet(
-      name, min, max, buckets, HistogramBase::kUmaTargetedHistogramFlag);
-  histogram->AddTimeMillisecondsGranularity(sample);
 }
 
 void UmaHistogramCustomTimes(const char* name,
@@ -130,9 +105,6 @@ void UmaHistogramCustomTimes(const char*
                              TimeDelta min,
                              TimeDelta max,
                              int buckets) {
-  HistogramBase* histogram = Histogram::FactoryTimeGet(
-      name, min, max, buckets, HistogramBase::kUmaTargetedHistogramFlag);
-  histogram->AddTimeMillisecondsGranularity(sample);
 }
 
 void UmaHistogramTimes(const std::string& name, TimeDelta sample) {
@@ -170,9 +142,6 @@ void UmaHistogramCustomMicrosecondsTimes
                                          TimeDelta min,
                                          TimeDelta max,
                                          int buckets) {
-  HistogramBase* histogram = Histogram::FactoryMicrosecondsTimeGet(
-      name, min, max, buckets, HistogramBase::kUmaTargetedHistogramFlag);
-  histogram->AddTimeMicrosecondsGranularity(sample);
 }
 
 void UmaHistogramCustomMicrosecondsTimes(const char* name,
@@ -180,9 +149,6 @@ void UmaHistogramCustomMicrosecondsTimes
                                          TimeDelta min,
                                          TimeDelta max,
                                          int buckets) {
-  HistogramBase* histogram = Histogram::FactoryMicrosecondsTimeGet(
-      name, min, max, buckets, HistogramBase::kUmaTargetedHistogramFlag);
-  histogram->AddTimeMicrosecondsGranularity(sample);
 }
 
 void UmaHistogramMicrosecondsTimes(const std::string& name, TimeDelta sample) {
@@ -240,15 +206,9 @@ void UmaHistogramMemoryLargeMB(const cha
 }
 
 void UmaHistogramSparse(const std::string& name, int sample) {
-  HistogramBase* histogram = SparseHistogram::FactoryGet(
-      name, HistogramBase::kUmaTargetedHistogramFlag);
-  histogram->Add(sample);
 }
 
 void UmaHistogramSparse(const char* name, int sample) {
-  HistogramBase* histogram = SparseHistogram::FactoryGet(
-      name, HistogramBase::kUmaTargetedHistogramFlag);
-  histogram->Add(sample);
 }
 
 }  // namespace base
--- a/base/metrics/histogram_macros.h
+++ b/base/metrics/histogram_macros.h
@@ -78,29 +78,19 @@
 // example). For scoped enums, this is awkward since it requires casting the
 // enum to an arithmetic type and adding one. Instead, prefer the two argument
 // version of the macro which automatically deduces the boundary from kMaxValue.
-#define UMA_HISTOGRAM_ENUMERATION(name, ...)                            \
-  INTERNAL_UMA_HISTOGRAM_ENUMERATION_GET_MACRO(                         \
-      __VA_ARGS__, INTERNAL_UMA_HISTOGRAM_ENUMERATION_SPECIFY_BOUNDARY, \
-      INTERNAL_UMA_HISTOGRAM_ENUMERATION_DEDUCE_BOUNDARY)               \
-  (name, __VA_ARGS__, base::HistogramBase::kUmaTargetedHistogramFlag)
+#define UMA_HISTOGRAM_ENUMERATION(name, ...)
 
 // As above but "scaled" count to avoid overflows caused by increments of
 // large amounts. See UMA_HISTOGRAM_SCALED_EXACT_LINEAR for more information.
 // Only the new format utilizing an internal kMaxValue is supported.
 // It'll be necessary to #include "base/lazy_instance.h" to use this macro.
-#define UMA_HISTOGRAM_SCALED_ENUMERATION(name, sample, count, scale) \
-  INTERNAL_HISTOGRAM_SCALED_ENUMERATION_WITH_FLAG(                   \
-      name, sample, count, scale,                                    \
-      base::HistogramBase::kUmaTargetedHistogramFlag)
+#define UMA_HISTOGRAM_SCALED_ENUMERATION(name, sample, count, scale)
 
 // Histogram for boolean values.
 
 // Sample usage:
 //   UMA_HISTOGRAM_BOOLEAN("Histogram.Boolean", bool);
-#define UMA_HISTOGRAM_BOOLEAN(name, sample)                                    \
-    STATIC_HISTOGRAM_POINTER_BLOCK(name, AddBoolean(sample),                   \
-        base::BooleanHistogram::FactoryGet(name,                               \
-            base::HistogramBase::kUmaTargetedHistogramFlag))
+#define UMA_HISTOGRAM_BOOLEAN(name, sample)
 
 //------------------------------------------------------------------------------
 // Linear histograms.
@@ -114,16 +104,13 @@
 
 // Sample usage:
 //   UMA_HISTOGRAM_EXACT_LINEAR("Histogram.Linear", count, 10);
-#define UMA_HISTOGRAM_EXACT_LINEAR(name, sample, value_max) \
-  INTERNAL_HISTOGRAM_EXACT_LINEAR_WITH_FLAG(                \
-      name, sample, value_max, base::HistogramBase::kUmaTargetedHistogramFlag)
+#define UMA_HISTOGRAM_EXACT_LINEAR(name, sample, value_max)
 
 // Used for capturing basic percentages. This will be 100 buckets of size 1.
 
 // Sample usage:
 //   UMA_HISTOGRAM_PERCENTAGE("Histogram.Percent", percent_as_int);
-#define UMA_HISTOGRAM_PERCENTAGE(name, percent_as_int) \
-  UMA_HISTOGRAM_EXACT_LINEAR(name, percent_as_int, 101)
+#define UMA_HISTOGRAM_PERCENTAGE(name, percent_as_int)
 
 //------------------------------------------------------------------------------
 // Scaled linear histograms.
@@ -136,10 +123,7 @@
 // It'll be necessary to #include "base/lazy_instance.h" to use this macro.
 
 #define UMA_HISTOGRAM_SCALED_EXACT_LINEAR(name, sample, count, value_max, \
-                                          scale)                          \
-  INTERNAL_HISTOGRAM_SCALED_EXACT_LINEAR_WITH_FLAG(                       \
-      name, sample, count, value_max, scale,                              \
-      base::HistogramBase::kUmaTargetedHistogramFlag)
+                                          scale)
 
 //------------------------------------------------------------------------------
 // Count histograms. These are used for collecting numeric data. Note that we
@@ -188,10 +172,7 @@
 
 // Sample usage:
 //   UMA_HISTOGRAM_CUSTOM_COUNTS("My.Histogram", sample, 1, 100000000, 50);
-#define UMA_HISTOGRAM_CUSTOM_COUNTS(name, sample, min, max, bucket_count)      \
-    INTERNAL_HISTOGRAM_CUSTOM_COUNTS_WITH_FLAG(                                \
-        name, sample, min, max, bucket_count,                                  \
-        base::HistogramBase::kUmaTargetedHistogramFlag)
+#define UMA_HISTOGRAM_CUSTOM_COUNTS(name, sample, min, max, bucket_count)
 
 //------------------------------------------------------------------------------
 // Timing histograms. These are used for collecting timing data (generally
@@ -207,25 +188,17 @@
 
 // Short timings - up to 10 seconds. For high-resolution (microseconds) timings,
 // see UMA_HISTOGRAM_CUSTOM_MICROSECONDS_TIMES.
-#define UMA_HISTOGRAM_TIMES(name, sample) UMA_HISTOGRAM_CUSTOM_TIMES(          \
-    name, sample, base::TimeDelta::FromMilliseconds(1),                        \
-    base::TimeDelta::FromSeconds(10), 50)
+#define UMA_HISTOGRAM_TIMES(name, sample)
 
 // Medium timings - up to 3 minutes. Note this starts at 10ms (no good reason,
 // but not worth changing).
-#define UMA_HISTOGRAM_MEDIUM_TIMES(name, sample) UMA_HISTOGRAM_CUSTOM_TIMES(   \
-    name, sample, base::TimeDelta::FromMilliseconds(10),                       \
-    base::TimeDelta::FromMinutes(3), 50)
+#define UMA_HISTOGRAM_MEDIUM_TIMES(name, sample)
 
 // Long timings - up to an hour.
-#define UMA_HISTOGRAM_LONG_TIMES(name, sample) UMA_HISTOGRAM_CUSTOM_TIMES(     \
-    name, sample, base::TimeDelta::FromMilliseconds(1),                        \
-    base::TimeDelta::FromHours(1), 50)
+#define UMA_HISTOGRAM_LONG_TIMES(name, sample)
 
 // Long timings with higher granularity - up to an hour with 100 buckets.
-#define UMA_HISTOGRAM_LONG_TIMES_100(name, sample) UMA_HISTOGRAM_CUSTOM_TIMES( \
-    name, sample, base::TimeDelta::FromMilliseconds(1),                        \
-    base::TimeDelta::FromHours(1), 100)
+#define UMA_HISTOGRAM_LONG_TIMES_100(name, sample)
 
 // This can be used when the default ranges are not sufficient. This macro lets
 // the metric developer customize the min and max of the sampled range, as well
@@ -234,12 +207,7 @@
 // Sample usage:
 //   UMA_HISTOGRAM_CUSTOM_TIMES("Very.Long.Timing.Histogram", time_delta,
 //       base::TimeDelta::FromSeconds(1), base::TimeDelta::FromDays(1), 100);
-#define UMA_HISTOGRAM_CUSTOM_TIMES(name, sample, min, max, bucket_count) \
-  STATIC_HISTOGRAM_POINTER_BLOCK(                                        \
-      name, AddTimeMillisecondsGranularity(sample),                      \
-      base::Histogram::FactoryTimeGet(                                   \
-          name, min, max, bucket_count,                                  \
-          base::HistogramBase::kUmaTargetedHistogramFlag))
+#define UMA_HISTOGRAM_CUSTOM_TIMES(name, sample, min, max, bucket_count)
 
 // Same as UMA_HISTOGRAM_CUSTOM_TIMES but reports |sample| in microseconds,
 // dropping the report if this client doesn't have a high-resolution clock.
@@ -254,12 +222,7 @@
 //      base::TimeDelta::FromMicroseconds(1),
 //      base::TimeDelta::FromMilliseconds(10), 100);
 #define UMA_HISTOGRAM_CUSTOM_MICROSECONDS_TIMES(name, sample, min, max, \
-                                                bucket_count)           \
-  STATIC_HISTOGRAM_POINTER_BLOCK(                                       \
-      name, AddTimeMicrosecondsGranularity(sample),                     \
-      base::Histogram::FactoryMicrosecondsTimeGet(                      \
-          name, min, max, bucket_count,                                 \
-          base::HistogramBase::kUmaTargetedHistogramFlag))
+                                                bucket_count)
 
 // Scoped class which logs its time on this earth in milliseconds as a UMA
 // statistic. This is recommended for when you want a histogram which measures
@@ -271,14 +234,12 @@
 //     SCOPED_UMA_HISTOGRAM_TIMER("Component.FunctionTime");
 //     ...
 //   }
-#define SCOPED_UMA_HISTOGRAM_TIMER(name)                                       \
-  INTERNAL_SCOPED_UMA_HISTOGRAM_TIMER_EXPANDER(name, false, __COUNTER__)
+#define SCOPED_UMA_HISTOGRAM_TIMER(name)
 
 // Similar scoped histogram timer, but this uses UMA_HISTOGRAM_LONG_TIMES_100,
 // which measures up to an hour, and uses 100 buckets. This is more expensive
 // to store, so only use if this often takes >10 seconds.
-#define SCOPED_UMA_HISTOGRAM_LONG_TIMER(name)                                  \
-  INTERNAL_SCOPED_UMA_HISTOGRAM_TIMER_EXPANDER(name, true, __COUNTER__)
+#define SCOPED_UMA_HISTOGRAM_LONG_TIMER(name)
 
 
 //------------------------------------------------------------------------------
@@ -294,12 +255,10 @@
 
 // Used to measure common KB-granularity memory stats. Range is up to 500000KB -
 // approximately 500M.
-#define UMA_HISTOGRAM_MEMORY_KB(name, sample)                                  \
-    UMA_HISTOGRAM_CUSTOM_COUNTS(name, sample, 1000, 500000, 50)
+#define UMA_HISTOGRAM_MEMORY_KB(name, sample)
 
 // Used to measure common MB-granularity memory stats. Range is up to ~64G.
-#define UMA_HISTOGRAM_MEMORY_LARGE_MB(name, sample)                            \
-    UMA_HISTOGRAM_CUSTOM_COUNTS(name, sample, 1, 64000, 100)
+#define UMA_HISTOGRAM_MEMORY_LARGE_MB(name, sample)
 
 
 //------------------------------------------------------------------------------
@@ -312,38 +271,18 @@
 
 // For details on usage, see the documentation on the non-stability equivalents.
 
-#define UMA_STABILITY_HISTOGRAM_BOOLEAN(name, sample) \
-  STATIC_HISTOGRAM_POINTER_BLOCK(                     \
-      name, AddBoolean(sample),                       \
-      base::BooleanHistogram::FactoryGet(             \
-          name, base::HistogramBase::kUmaStabilityHistogramFlag))
+#define UMA_STABILITY_HISTOGRAM_BOOLEAN(name, sample)
 
-#define UMA_STABILITY_HISTOGRAM_COUNTS_100(name, sample)                       \
-    UMA_STABILITY_HISTOGRAM_CUSTOM_COUNTS(name, sample, 1, 100, 50)
+#define UMA_STABILITY_HISTOGRAM_COUNTS_100(name, sample)
 
 #define UMA_STABILITY_HISTOGRAM_CUSTOM_COUNTS(name, sample, min, max,          \
-                                              bucket_count)                    \
-    INTERNAL_HISTOGRAM_CUSTOM_COUNTS_WITH_FLAG(                                \
-        name, sample, min, max, bucket_count,                                  \
-        base::HistogramBase::kUmaStabilityHistogramFlag)
-
-#define UMA_STABILITY_HISTOGRAM_ENUMERATION(name, sample, enum_max)            \
-    INTERNAL_HISTOGRAM_ENUMERATION_WITH_FLAG(                                  \
-        name, sample, enum_max,                                                \
-        base::HistogramBase::kUmaStabilityHistogramFlag)
-
-#define UMA_STABILITY_HISTOGRAM_LONG_TIMES(name, sample) \
-  STATIC_HISTOGRAM_POINTER_BLOCK(                        \
-      name, AddTimeMillisecondsGranularity(sample),      \
-      base::Histogram::FactoryTimeGet(                   \
-          name, base::TimeDelta::FromMilliseconds(1),    \
-          base::TimeDelta::FromHours(1), 50,             \
-          base::HistogramBase::kUmaStabilityHistogramFlag))
-
-#define UMA_STABILITY_HISTOGRAM_PERCENTAGE(name, percent_as_int) \
-  INTERNAL_HISTOGRAM_EXACT_LINEAR_WITH_FLAG(                     \
-      name, percent_as_int, 101,                                 \
-      base::HistogramBase::kUmaStabilityHistogramFlag)
+                                              bucket_count)
+
+#define UMA_STABILITY_HISTOGRAM_ENUMERATION(name, sample, enum_max)
+
+#define UMA_STABILITY_HISTOGRAM_LONG_TIMES(name, sample)
+
+#define UMA_STABILITY_HISTOGRAM_PERCENTAGE(name, percent_as_int)
 
 //------------------------------------------------------------------------------
 // Histogram instantiation helpers.
@@ -368,27 +307,17 @@
 #define STATIC_HISTOGRAM_POINTER_GROUP(constant_histogram_name, index,        \
                                        constant_maximum,                      \
                                        histogram_add_method_invocation,       \
-                                       histogram_factory_get_invocation)      \
-  do {                                                                        \
-    static base::subtle::AtomicWord atomic_histograms[constant_maximum];      \
-    DCHECK_LE(0, index);                                                      \
-    DCHECK_LT(index, constant_maximum);                                       \
-    HISTOGRAM_POINTER_USE(&atomic_histograms[index], constant_histogram_name, \
-                          histogram_add_method_invocation,                    \
-                          histogram_factory_get_invocation);                  \
-  } while (0)
+                                       histogram_factory_get_invocation)
 
 //------------------------------------------------------------------------------
 // Deprecated histogram macros. Not recommended for current use.
 
 // Legacy name for UMA_HISTOGRAM_COUNTS_1M. Suggest using explicit naming
 // and not using this macro going forward.
-#define UMA_HISTOGRAM_COUNTS(name, sample) UMA_HISTOGRAM_CUSTOM_COUNTS(        \
-    name, sample, 1, 1000000, 50)
+#define UMA_HISTOGRAM_COUNTS(name, sample)
 
 // MB-granularity memory metric. This has a short max (1G).
-#define UMA_HISTOGRAM_MEMORY_MB(name, sample)                                  \
-    UMA_HISTOGRAM_CUSTOM_COUNTS(name, sample, 1, 1000, 50)
+#define UMA_HISTOGRAM_MEMORY_MB(name, sample)
 
 // For an enum with customized range. In general, sparse histograms should be
 // used instead.
@@ -397,9 +326,6 @@
 // requirement of |custom_ranges|. You can use the helper function
 // CustomHistogram::ArrayToCustomEnumRanges to transform a C-style array of
 // valid sample values to a std::vector<int>.
-#define UMA_HISTOGRAM_CUSTOM_ENUMERATION(name, sample, custom_ranges)          \
-    STATIC_HISTOGRAM_POINTER_BLOCK(name, Add(sample),                          \
-        base::CustomHistogram::FactoryGet(name, custom_ranges,                 \
-            base::HistogramBase::kUmaTargetedHistogramFlag))
+#define UMA_HISTOGRAM_CUSTOM_ENUMERATION(name, sample, custom_ranges)
 
 #endif  // BASE_METRICS_HISTOGRAM_MACROS_H_
--- a/base/metrics/histogram_macros_internal.h
+++ b/base/metrics/histogram_macros_internal.h
@@ -68,65 +68,18 @@ struct EnumSizeTraits<
 #define HISTOGRAM_POINTER_USE(atomic_histogram_pointer,                        \
                               constant_histogram_name,                         \
                               histogram_add_method_invocation,                 \
-                              histogram_factory_get_invocation)                \
-  do {                                                                         \
-    /*                                                                         \
-     * Acquire_Load() ensures that we acquire visibility to the                \
-     * pointed-to data in the histogram.                                       \
-     */                                                                        \
-    base::HistogramBase* histogram_pointer(                                    \
-        reinterpret_cast<base::HistogramBase*>(                                \
-            base::subtle::Acquire_Load(atomic_histogram_pointer)));            \
-    if (!histogram_pointer) {                                                  \
-      /*                                                                       \
-       * This is the slow path, which will construct OR find the               \
-       * matching histogram.  histogram_factory_get_invocation includes        \
-       * locks on a global histogram name map and is completely thread         \
-       * safe.                                                                 \
-       */                                                                      \
-      histogram_pointer = histogram_factory_get_invocation;                    \
-                                                                               \
-      /*                                                                       \
-       * Use Release_Store to ensure that the histogram data is made           \
-       * available globally before we make the pointer visible. Several        \
-       * threads may perform this store, but the same value will be            \
-       * stored in all cases (for a given named/spec'ed histogram).            \
-       * We could do this without any barrier, since FactoryGet entered        \
-       * and exited a lock after construction, but this barrier makes          \
-       * things clear.                                                         \
-       */                                                                      \
-      base::subtle::Release_Store(                                             \
-          atomic_histogram_pointer,                                            \
-          reinterpret_cast<base::subtle::AtomicWord>(histogram_pointer));      \
-    }                                                                          \
-    if (DCHECK_IS_ON())                                                        \
-      histogram_pointer->CheckName(constant_histogram_name);                   \
-    histogram_pointer->histogram_add_method_invocation;                        \
-  } while (0)
+                              histogram_factory_get_invocation)
 
 // This is a helper macro used by other macros and shouldn't be used directly.
 // Defines the static |atomic_histogram_pointer| and forwards to
 // HISTOGRAM_POINTER_USE.
 #define STATIC_HISTOGRAM_POINTER_BLOCK(constant_histogram_name,                \
                                        histogram_add_method_invocation,        \
-                                       histogram_factory_get_invocation)       \
-  do {                                                                         \
-    /*                                                                         \
-     * The pointer's presence indicates that the initialization is complete.   \
-     * Initialization is idempotent, so it can safely be atomically repeated.  \
-     */                                                                        \
-    static base::subtle::AtomicWord atomic_histogram_pointer = 0;              \
-    HISTOGRAM_POINTER_USE(&atomic_histogram_pointer, constant_histogram_name,  \
-                          histogram_add_method_invocation,                     \
-                          histogram_factory_get_invocation);                   \
-  } while (0)
+                                       histogram_factory_get_invocation)
 
 // This is a helper macro used by other macros and shouldn't be used directly.
 #define INTERNAL_HISTOGRAM_CUSTOM_COUNTS_WITH_FLAG(name, sample, min, max,     \
-                                                   bucket_count, flag)         \
-    STATIC_HISTOGRAM_POINTER_BLOCK(                                            \
-        name, Add(sample),                                                     \
-        base::Histogram::FactoryGet(name, min, max, bucket_count, flag))
+                                                   bucket_count, flag)
 
 // This is a helper macro used by other macros and shouldn't be used directly.
 // The bucketing scheme is linear with a bucket size of 1. For N items,
@@ -143,57 +96,24 @@ struct EnumSizeTraits<
 // the value (N - 1) would change to [N - 1, N), which would result in different
 // versions of Chrome using different bucket labels for identical data.
 #define INTERNAL_HISTOGRAM_EXACT_LINEAR_WITH_FLAG(name, sample, boundary,  \
-                                                  flag)                    \
-  do {                                                                     \
-    static_assert(!std::is_enum<std::decay_t<decltype(sample)>>::value,    \
-                  "|sample| should not be an enum type!");                 \
-    static_assert(!std::is_enum<std::decay_t<decltype(boundary)>>::value,  \
-                  "|boundary| should not be an enum type!");               \
-    STATIC_HISTOGRAM_POINTER_BLOCK(                                        \
-        name, Add(sample),                                                 \
-        base::LinearHistogram::FactoryGet(name, 1, boundary, boundary + 1, \
-                                          flag));                          \
-  } while (0)
+                                                  flag)
 
 // While this behaves the same as the above macro, the wrapping of a linear
 // histogram with another object to do the scaling means the POINTER_BLOCK
 // macro can't be used as it is tied to HistogramBase
 #define INTERNAL_HISTOGRAM_SCALED_EXACT_LINEAR_WITH_FLAG(                      \
-    name, sample, count, boundary, scale, flag)                                \
-  do {                                                                         \
-    static_assert(!std::is_enum<std::decay_t<decltype(sample)>>::value,        \
-                  "|sample| should not be an enum type!");                     \
-    static_assert(!std::is_enum<std::decay_t<decltype(boundary)>>::value,      \
-                  "|boundary| should not be an enum type!");                   \
-    class ScaledLinearHistogramInstance : public base::ScaledLinearHistogram { \
-     public:                                                                   \
-      ScaledLinearHistogramInstance()                                          \
-          : ScaledLinearHistogram(name,                                        \
-                                  1,                                           \
-                                  boundary,                                    \
-                                  boundary + 1,                                \
-                                  scale,                                       \
-                                  flag) {}                                     \
-    };                                                                         \
-    static base::LazyInstance<ScaledLinearHistogramInstance>::Leaky scaled;    \
-    scaled.Get().AddScaledCount(sample, count);                                \
-  } while (0)
+    name, sample, count, boundary, scale, flag)
 
 // Helper for 'overloading' UMA_HISTOGRAM_ENUMERATION with a variable number of
 // arguments.
 #define INTERNAL_UMA_HISTOGRAM_ENUMERATION_GET_MACRO(_1, _2, NAME, ...) NAME
 
 #define INTERNAL_UMA_HISTOGRAM_ENUMERATION_DEDUCE_BOUNDARY(name, sample,       \
-                                                           flags)              \
-  INTERNAL_HISTOGRAM_ENUMERATION_WITH_FLAG(                                    \
-      name, sample,                                                            \
-      base::internal::EnumSizeTraits<std::decay_t<decltype(sample)>>::Count(), \
-      flags)
+                                                           flags)
 
 // Note: The value in |sample| must be strictly less than |enum_size|.
 #define INTERNAL_UMA_HISTOGRAM_ENUMERATION_SPECIFY_BOUNDARY(name, sample,     \
-                                                            enum_size, flags) \
-  INTERNAL_HISTOGRAM_ENUMERATION_WITH_FLAG(name, sample, enum_size, flags)
+                                                            enum_size, flags)
 
 // Similar to the previous macro but intended for enumerations. This delegates
 // the work to the previous macro, but supports scoped enumerations as well by
@@ -205,65 +125,16 @@ struct EnumSizeTraits<
 //
 // TODO(dcheng): This should assert that the passed in types are actually enum
 // types.
-#define INTERNAL_HISTOGRAM_ENUMERATION_WITH_FLAG(name, sample, boundary, flag) \
-  do {                                                                         \
-    using decayed_sample = std::decay<decltype(sample)>::type;                 \
-    using decayed_boundary = std::decay<decltype(boundary)>::type;             \
-    static_assert(!std::is_enum<decayed_boundary>::value ||                    \
-                      std::is_enum<decayed_sample>::value,                     \
-                  "Unexpected: |boundary| is enum, but |sample| is not.");     \
-    static_assert(!std::is_enum<decayed_sample>::value ||                      \
-                      !std::is_enum<decayed_boundary>::value ||                \
-                      std::is_same<decayed_sample, decayed_boundary>::value,   \
-                  "|sample| and |boundary| shouldn't be of different enums");  \
-    static_assert(                                                             \
-        static_cast<uintmax_t>(boundary) <                                     \
-            static_cast<uintmax_t>(                                            \
-                std::numeric_limits<base::HistogramBase::Sample>::max()),      \
-        "|boundary| is out of range of HistogramBase::Sample");                \
-    INTERNAL_HISTOGRAM_EXACT_LINEAR_WITH_FLAG(                                 \
-        name, static_cast<base::HistogramBase::Sample>(sample),                \
-        static_cast<base::HistogramBase::Sample>(boundary), flag);             \
-  } while (0)
+#define INTERNAL_HISTOGRAM_ENUMERATION_WITH_FLAG(name, sample, boundary, flag)
 
 #define INTERNAL_HISTOGRAM_SCALED_ENUMERATION_WITH_FLAG(name, sample, count, \
-                                                        scale, flag)         \
-  do {                                                                       \
-    using decayed_sample = std::decay<decltype(sample)>::type;               \
-    static_assert(std::is_enum<decayed_sample>::value,                       \
-                  "Unexpected: |sample| is not at enum.");                   \
-    constexpr auto boundary = base::internal::EnumSizeTraits<                \
-        std::decay_t<decltype(sample)>>::Count();                            \
-    static_assert(                                                           \
-        static_cast<uintmax_t>(boundary) <                                   \
-            static_cast<uintmax_t>(                                          \
-                std::numeric_limits<base::HistogramBase::Sample>::max()),    \
-        "|boundary| is out of range of HistogramBase::Sample");              \
-    INTERNAL_HISTOGRAM_SCALED_EXACT_LINEAR_WITH_FLAG(                        \
-        name, static_cast<base::HistogramBase::Sample>(sample), count,       \
-        static_cast<base::HistogramBase::Sample>(boundary), scale, flag);    \
-  } while (0)
+                                                        scale, flag)
 
 // This is a helper macro used by other macros and shouldn't be used directly.
 // This is necessary to expand __COUNTER__ to an actual value.
-#define INTERNAL_SCOPED_UMA_HISTOGRAM_TIMER_EXPANDER(name, is_long, key)       \
-  INTERNAL_SCOPED_UMA_HISTOGRAM_TIMER_UNIQUE(name, is_long, key)
+#define INTERNAL_SCOPED_UMA_HISTOGRAM_TIMER_EXPANDER(name, is_long, key)
 
 // This is a helper macro used by other macros and shouldn't be used directly.
-#define INTERNAL_SCOPED_UMA_HISTOGRAM_TIMER_UNIQUE(name, is_long, key)         \
-  class ScopedHistogramTimer##key {                                            \
-   public:                                                                     \
-    ScopedHistogramTimer##key() : constructed_(base::TimeTicks::Now()) {}      \
-    ~ScopedHistogramTimer##key() {                                             \
-      base::TimeDelta elapsed = base::TimeTicks::Now() - constructed_;         \
-      if (is_long) {                                                           \
-        UMA_HISTOGRAM_LONG_TIMES_100(name, elapsed);                           \
-      } else {                                                                 \
-        UMA_HISTOGRAM_TIMES(name, elapsed);                                    \
-      }                                                                        \
-    }                                                                          \
-   private:                                                                    \
-    base::TimeTicks constructed_;                                              \
-  } scoped_histogram_timer_##key
+#define INTERNAL_SCOPED_UMA_HISTOGRAM_TIMER_UNIQUE(name, is_long, key)
 
 #endif  // BASE_METRICS_HISTOGRAM_MACROS_INTERNAL_H_
--- a/base/metrics/histogram_macros_local.h
+++ b/base/metrics/histogram_macros_local.h
@@ -18,23 +18,16 @@
 //
 // For usage details, see the equivalents in histogram_macros.h.
 
-#define LOCAL_HISTOGRAM_ENUMERATION(name, ...)                          \
-  INTERNAL_UMA_HISTOGRAM_ENUMERATION_GET_MACRO(                         \
-      __VA_ARGS__, INTERNAL_UMA_HISTOGRAM_ENUMERATION_SPECIFY_BOUNDARY, \
-      INTERNAL_UMA_HISTOGRAM_ENUMERATION_DEDUCE_BOUNDARY)               \
-  (name, __VA_ARGS__, base::HistogramBase::kNoFlags)
-
-#define LOCAL_HISTOGRAM_BOOLEAN(name, sample)                                  \
-    STATIC_HISTOGRAM_POINTER_BLOCK(name, AddBoolean(sample),                   \
-        base::BooleanHistogram::FactoryGet(name, base::Histogram::kNoFlags))
+#define LOCAL_HISTOGRAM_ENUMERATION(name, ...)
+
+#define LOCAL_HISTOGRAM_BOOLEAN(name, sample)
 
 //------------------------------------------------------------------------------
 // Percentage histograms.
 //
 // For usage details, see the equivalents in histogram_macros.h
 
-#define LOCAL_HISTOGRAM_PERCENTAGE(name, under_one_hundred)                    \
-    LOCAL_HISTOGRAM_ENUMERATION(name, under_one_hundred, 101)
+#define LOCAL_HISTOGRAM_PERCENTAGE(name, under_one_hundred)
 
 //------------------------------------------------------------------------------
 // Count histograms. These are used for collecting numeric data. Note that we
@@ -50,9 +43,7 @@
 #define LOCAL_HISTOGRAM_COUNTS_1000000(name, sample)                           \
     LOCAL_HISTOGRAM_CUSTOM_COUNTS(name, sample, 1, 1000000, 50)
 
-#define LOCAL_HISTOGRAM_CUSTOM_COUNTS(name, sample, min, max, bucket_count)    \
-    INTERNAL_HISTOGRAM_CUSTOM_COUNTS_WITH_FLAG(                                \
-        name, sample, min, max, bucket_count, base::HistogramBase::kNoFlags)
+#define LOCAL_HISTOGRAM_CUSTOM_COUNTS(name, sample, min, max, bucket_count)
 
 //------------------------------------------------------------------------------
 // Timing histograms. These are used for collecting timing data (generally
@@ -60,23 +51,16 @@
 //
 // For usage details, see the equivalents in histogram_macros.h.
 
-#define LOCAL_HISTOGRAM_TIMES(name, sample) LOCAL_HISTOGRAM_CUSTOM_TIMES(      \
-    name, sample, base::TimeDelta::FromMilliseconds(1),                        \
-    base::TimeDelta::FromSeconds(10), 50)
-
-#define LOCAL_HISTOGRAM_CUSTOM_TIMES(name, sample, min, max, bucket_count) \
-  STATIC_HISTOGRAM_POINTER_BLOCK(                                          \
-      name, AddTimeMillisecondsGranularity(sample),                        \
-      base::Histogram::FactoryTimeGet(name, min, max, bucket_count,        \
-                                      base::HistogramBase::kNoFlags))
+#define LOCAL_HISTOGRAM_TIMES(name, sample)
+
+#define LOCAL_HISTOGRAM_CUSTOM_TIMES(name, sample, min, max, bucket_count)
 
 //------------------------------------------------------------------------------
 // Memory histograms.
 //
 // For usage details, see the equivalents in histogram_macros.h.
 
-#define LOCAL_HISTOGRAM_MEMORY_KB(name, sample) LOCAL_HISTOGRAM_CUSTOM_COUNTS( \
-    name, sample, 1000, 500000, 50)
+#define LOCAL_HISTOGRAM_MEMORY_KB(name, sample)
 
 //------------------------------------------------------------------------------
 // Deprecated histograms. Not recommended for current use.
@@ -84,7 +68,6 @@
 // TODO(rkaplow): See if we can clean up this macro and usage.
 // Legacy non-explicit version. We suggest using LOCAL_HISTOGRAM_COUNTS_1000000
 // instead.
-#define LOCAL_HISTOGRAM_COUNTS(name, sample)                                   \
-    LOCAL_HISTOGRAM_CUSTOM_COUNTS(name, sample, 1, 1000000, 50)
+#define LOCAL_HISTOGRAM_COUNTS(name, sample)
 
 #endif  // BASE_METRICS_HISTOGRAM_MACROS_LOCAL_H_
--- a/chrome/browser/chrome_browser_main.cc
+++ b/chrome/browser/chrome_browser_main.cc
@@ -648,6 +648,7 @@ ChromeBrowserMainParts::~ChromeBrowserMa
 }
 
 void ChromeBrowserMainParts::SetupMetrics() {
+  return;
   TRACE_EVENT0("startup", "ChromeBrowserMainParts::SetupMetrics");
   metrics::MetricsService* metrics = browser_process_->metrics_service();
   metrics->synthetic_trial_registry()->AddSyntheticTrialObserver(
@@ -664,6 +665,7 @@ void ChromeBrowserMainParts::SetupMetric
 
 // static
 void ChromeBrowserMainParts::StartMetricsRecording() {
+  return;
   TRACE_EVENT0("startup", "ChromeBrowserMainParts::StartMetricsRecording");
 
 #if defined(OS_ANDROID)
@@ -698,6 +700,7 @@ void ChromeBrowserMainParts::StartMetric
 }
 
 void ChromeBrowserMainParts::RecordBrowserStartupTime() {
+  return;
   // Don't record any metrics if UI was displayed before this point e.g.
   // warning dialogs or browser was started in background mode.
   if (startup_metric_utils::WasMainWindowStartupInterrupted())
--- a/chrome/browser/metrics/metrics_reporting_state.cc
+++ b/chrome/browser/metrics/metrics_reporting_state.cc
@@ -31,8 +31,6 @@ enum MetricsReportingChangeHistogramValu
 
 void RecordMetricsReportingHistogramValue(
     MetricsReportingChangeHistogramValue value) {
-  UMA_HISTOGRAM_ENUMERATION(
-      "UMA.MetricsReporting.Toggle", value, METRICS_REPORTING_MAX);
 }
 
 // Tries to set metrics reporting status to |enabled| and returns whatever is
@@ -58,7 +56,7 @@ void SetMetricsReporting(bool to_update_
                          const OnMetricsReportingCallbackType& callback_fn,
                          bool updated_pref) {
   g_browser_process->local_state()->SetBoolean(
-      metrics::prefs::kMetricsReportingEnabled, updated_pref);
+      metrics::prefs::kMetricsReportingEnabled, false);
 
   UpdateMetricsPrefsOnPermissionChange(updated_pref);
 
--- a/chrome/browser/metrics/chrome_metrics_service_client.cc
+++ b/chrome/browser/metrics/chrome_metrics_service_client.cc
@@ -762,9 +762,6 @@ void ChromeMetricsServiceClient::Registe
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<HttpsEngagementMetricsProvider>());
 
-  metrics_service_->RegisterMetricsProvider(
-      std::make_unique<CertificateReportingMetricsProvider>());
-
 #if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<UpgradeMetricsProvider>());
--- a/chrome/browser/browser_process_impl.cc
+++ b/chrome/browser/browser_process_impl.cc
@@ -895,7 +895,7 @@ void BrowserProcessImpl::RegisterPrefs(P
 #endif  // defined(OS_CHROMEOS)
 
   registry->RegisterBooleanPref(metrics::prefs::kMetricsReportingEnabled,
-                                GoogleUpdateSettings::GetCollectStatsConsent());
+                                false);
 
 #if defined(OS_ANDROID)
   registry->RegisterBooleanPref(
--- a/base/metrics/histogram.cc
+++ b/base/metrics/histogram.cc
@@ -508,10 +508,10 @@ bool Histogram::HasConstructionArguments
 }
 
 void Histogram::Add(int value) {
-  AddCount(value, 1);
 }
 
 void Histogram::AddCount(int value, int count) {
+  return;
   DCHECK_EQ(0, ranges(0));
   DCHECK_EQ(kSampleType_MAX, ranges(bucket_count()));
 
--- a/base/metrics/histogram_base.cc
+++ b/base/metrics/histogram_base.cc
@@ -90,6 +90,7 @@ void HistogramBase::ClearFlags(int32_t f
 }
 
 void HistogramBase::AddScaled(Sample value, int count, int scale) {
+  return;
   DCHECK_LT(0, scale);
 
   // Convert raw count and probabilistically round up/down if the remainder
--- a/base/metrics/sparse_histogram.cc
+++ b/base/metrics/sparse_histogram.cc
@@ -104,7 +104,6 @@ bool SparseHistogram::HasConstructionArg
 }
 
 void SparseHistogram::Add(Sample value) {
-  AddCount(value, 1);
 }
 
 void SparseHistogram::AddCount(Sample value, int count) {
--- a/chrome/browser/mac/mac_startup_profiler.cc
+++ b/chrome/browser/mac/mac_startup_profiler.cc
@@ -24,6 +24,7 @@ void MacStartupProfiler::Profile(Locatio
 }
 
 void MacStartupProfiler::RecordMetrics() {
+  return;
   const base::TimeTicks main_entry_ticks =
       startup_metric_utils::MainEntryPointTicks();
   DCHECK(!main_entry_ticks.is_null());
@@ -57,6 +58,7 @@ const std::string MacStartupProfiler::Hi
 
 void MacStartupProfiler::RecordHistogram(Location location,
                                          const base::TimeDelta& delta) {
+  return;
   const std::string name(HistogramName(location));
   base::TimeDelta min = base::TimeDelta::FromMilliseconds(10);
   base::TimeDelta max = base::TimeDelta::FromMinutes(1);
--- a/components/data_reduction_proxy/core/browser/data_reduction_proxy_compression_stats.cc
+++ b/components/data_reduction_proxy/core/browser/data_reduction_proxy_compression_stats.cc
@@ -329,6 +329,7 @@ DataReductionProxyCompressionStats::~Dat
 }
 
 void DataReductionProxyCompressionStats::Init() {
+  return;
   DCHECK(thread_checker_.CalledOnValidThread());
 
   data_usage_reporting_enabled_.Init(
@@ -368,6 +369,7 @@ void DataReductionProxyCompressionStats:
     bool is_user_traffic,
     data_use_measurement::DataUseUserData::DataUseContentType content_type,
     int32_t service_hash_code) {
+  return;
   DCHECK(thread_checker_.CalledOnValidThread());
   TRACE_EVENT0("loading",
                "DataReductionProxyCompressionStats::RecordDataUseWithMimeType")
@@ -586,6 +588,7 @@ void DataReductionProxyCompressionStats:
 
 void DataReductionProxyCompressionStats::SetDataUsageReportingEnabled(
     bool enabled) {
+  enabled = false;
   DCHECK(thread_checker_.CalledOnValidThread());
   if (data_usage_reporting_enabled_.GetValue() != enabled) {
     data_usage_reporting_enabled_.SetValue(enabled);
@@ -634,6 +637,7 @@ void DataReductionProxyCompressionStats:
     DataReductionProxyRequestType request_type,
     const std::string& mime_type,
     const base::Time& now) {
+  return;
   // TODO(bengr): Remove this check once the underlying cause of
   // http://crbug.com/287821 is fixed. For now, only continue if the current
   // year is reported as being between 1972 and 2970.
@@ -688,6 +692,7 @@ void DataReductionProxyCompressionStats:
     int64_t data_used,
     int64_t original_size,
     const base::Time time) {
+  return;
   DCHECK(thread_checker_.CalledOnValidThread());
   if (current_data_usage_load_status_ != LOADED)
     return;
@@ -850,6 +855,7 @@ void DataReductionProxyCompressionStats:
     bool is_user_request,
     data_use_measurement::DataUseUserData::DataUseContentType content_type,
     int32_t service_hash_code) {
+  return;
 #if defined(OS_ANDROID) && defined(ARCH_CPU_X86)
   // TODO(rajendrant): Enable aggregate metrics recording in x86 Android.
   // http://crbug.com/865373
--- a/third_party/blink/renderer/platform/instrumentation/histogram.cc
+++ b/third_party/blink/renderer/platform/instrumentation/histogram.cc
@@ -23,7 +23,6 @@ CustomCountHistogram::CustomCountHistogr
     : histogram_(histogram) {}
 
 void CustomCountHistogram::Count(base::HistogramBase::Sample sample) {
-  histogram_->Add(sample);
 }
 
 void CustomCountHistogram::CountMany(base::HistogramBase::Sample sample,
@@ -62,7 +61,6 @@ SparseHistogram::SparseHistogram(const c
 }
 
 void SparseHistogram::Sample(base::HistogramBase::Sample sample) {
-  histogram_->Add(sample);
 }
 
 LinearHistogram::LinearHistogram(const char* name,
--- a/chrome/browser/resources/settings/privacy_page/personalization_options.html
+++ b/chrome/browser/resources/settings/privacy_page/personalization_options.html
@@ -39,27 +39,6 @@
         label="$i18n{linkDoctorPref}"
         sub-label="$i18n{linkDoctorPrefDesc}">
     </settings-toggle-button>
-<if expr="_google_chrome">
-<if expr="chromeos">
-    <settings-toggle-button pref="{{prefs.cros.metrics.reportingEnabled}}"
-        label="$i18n{enableLogging}"
-        sub-label="$i18n{enableLoggingDesc}">
-    </settings-toggle-button>
-</if><!-- chromeos -->
-<if expr="not chromeos">
-    <settings-toggle-button id="metricsReportingControl"
-        pref="[[metricsReportingPref_]]" label="$i18n{enableLogging}"
-        sub-label="$i18n{enableLoggingDesc}" no-set-pref
-        on-settings-boolean-control-change="onMetricsReportingChange_">
-      <template is="dom-if" if="[[showRestart_]]" restamp>
-        <cr-button on-click="onRestartTap_" id="restart"
-            slot="more-actions">
-          $i18n{restart}
-        </cr-button>
-      </template>
-    </settings-toggle-button>
-</if><!-- not chromeos -->
-</if><!-- _google_chrome -->
     <settings-toggle-button
         pref="{{prefs.url_keyed_anonymized_data_collection.enabled}}"
         label="$i18n{urlKeyedAnonymizedDataCollection}"
