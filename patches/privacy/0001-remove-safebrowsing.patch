--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -1851,7 +1851,6 @@ jumbo_static_library("browser") {
   allow_circular_includes_from = [
     "//chrome/browser/ui",
     "//chrome/browser/ui/webui/bluetooth_internals",
-    "//chrome/browser/safe_browsing",
   ]
 
   public_deps = [
@@ -1901,7 +1900,6 @@ jumbo_static_library("browser") {
     "//chrome/browser/push_messaging:budget_proto",
     "//chrome/browser/resource_coordinator:mojo_bindings",
     "//chrome/browser/resource_coordinator:tab_manager_features",
-    "//chrome/browser/safe_browsing",
     "//chrome/browser/sharing/proto",
     "//chrome/browser/ssl:proto",
     "//chrome/browser/touch_to_fill",
@@ -2986,8 +2984,6 @@ jumbo_static_library("browser") {
       "download/download_commands.h",
       "download/download_crx_util.cc",
       "download/download_crx_util.h",
-      "download/download_danger_prompt.cc",
-      "download/download_danger_prompt.h",
       "download/download_dir_policy_handler.cc",
       "download/download_dir_policy_handler.h",
       "download/download_dir_util.cc",
@@ -5353,10 +5349,8 @@ grit("resources") {
     }
   }
 
-  if (safe_browsing_mode > 0) {
     deps +=
         [ "//chrome/browser/resources/safe_browsing:make_file_types_protobuf" ]
-  }
 
   if (safe_browsing_mode == 1) {
     deps += [ "//chrome/browser/ui/webui/reset_password:mojo_bindings_js" ]
--- a/chrome/browser/browser_process.h
+++ b/chrome/browser/browser_process.h
@@ -45,10 +45,6 @@ class NetworkQualityTracker;
 class SharedURLLoaderFactory;
 }
 
-namespace safe_browsing {
-class SafeBrowsingService;
-}
-
 namespace subresource_filter {
 class RulesetService;
 }
@@ -106,10 +102,6 @@ class ResourceCoordinatorParts;
 class TabManager;
 }
 
-namespace safe_browsing {
-class ClientSideDetectionService;
-}
-
 // NOT THREAD SAFE, call only from the main thread.
 // These functions shouldn't return NULL unless otherwise noted.
 class BrowserProcess {
@@ -210,14 +202,6 @@ class BrowserProcess {
   // on this platform (or this is a unit test).
   virtual StatusTray* status_tray() = 0;
 
-  // Returns the SafeBrowsing service.
-  virtual safe_browsing::SafeBrowsingService* safe_browsing_service() = 0;
-
-  // Returns an object which handles communication with the SafeBrowsing
-  // client-side detection servers.
-  virtual safe_browsing::ClientSideDetectionService*
-      safe_browsing_detection_service() = 0;
-
   // Returns the service providing versioned storage for rules used by the Safe
   // Browsing subresource filter.
   virtual subresource_filter::RulesetService*
--- a/chrome/browser/browser_process_impl.cc
+++ b/chrome/browser/browser_process_impl.cc
@@ -69,7 +69,6 @@
 #include "chrome/browser/printing/print_preview_dialog_controller.h"
 #include "chrome/browser/profiles/profile_manager.h"
 #include "chrome/browser/resource_coordinator/resource_coordinator_parts.h"
-#include "chrome/browser/safe_browsing/safe_browsing_service.h"
 #include "chrome/browser/shell_integration.h"
 #include "chrome/browser/site_isolation/prefs_observer.h"
 #include "chrome/browser/ssl/secure_origin_prefs_observer.h"
@@ -106,7 +105,6 @@
 #include "components/prefs/pref_service.h"
 #include "components/rappor/public/rappor_utils.h"
 #include "components/rappor/rappor_service_impl.h"
-#include "components/safe_browsing/safe_browsing_service_interface.h"
 #include "components/sessions/core/session_id_generator.h"
 #include "components/subresource_filter/content/browser/ruleset_service.h"
 #include "components/subresource_filter/core/browser/subresource_filter_constants.h"
@@ -362,8 +360,6 @@ void BrowserProcessImpl::StartTearDown()
 
   metrics_services_manager_.reset();
   intranet_redirect_detector_.reset();
-  if (safe_browsing_service_.get())
-    safe_browsing_service()->ShutDown();
   network_time_tracker_.reset();
 #if BUILDFLAG(ENABLE_PLUGINS)
   plugins_resource_service_.reset();
@@ -950,22 +946,6 @@ StatusTray* BrowserProcessImpl::status_t
   return status_tray_.get();
 }
 
-safe_browsing::SafeBrowsingService*
-BrowserProcessImpl::safe_browsing_service() {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  if (!created_safe_browsing_service_)
-    CreateSafeBrowsingService();
-  return safe_browsing_service_.get();
-}
-
-safe_browsing::ClientSideDetectionService*
-    BrowserProcessImpl::safe_browsing_detection_service() {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  if (safe_browsing_service())
-    return safe_browsing_service()->safe_browsing_detection_service();
-  return NULL;
-}
-
 subresource_filter::RulesetService*
 BrowserProcessImpl::subresource_filter_ruleset_service() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
@@ -1221,26 +1201,6 @@ void BrowserProcessImpl::CreateBackgroun
 #endif
 }
 
-void BrowserProcessImpl::CreateSafeBrowsingService() {
-  DCHECK(!safe_browsing_service_);
-  // Set this flag to true so that we don't retry indefinitely to
-  // create the service class if there was an error.
-  created_safe_browsing_service_ = true;
-
-  // The factory can be overridden in tests.
-  if (!safe_browsing::SafeBrowsingServiceInterface::HasFactory()) {
-    safe_browsing::SafeBrowsingServiceInterface::RegisterFactory(
-        safe_browsing::GetSafeBrowsingServiceFactory());
-  }
-
-  // TODO(crbug/925153): Port consumers of the |safe_browsing_service_| to use
-  // the interface in components/safe_browsing, and remove this cast.
-  safe_browsing_service_ = static_cast<safe_browsing::SafeBrowsingService*>(
-      safe_browsing::SafeBrowsingServiceInterface::CreateSafeBrowsingService());
-  if (safe_browsing_service_)
-    safe_browsing_service_->Initialize();
-}
-
 void BrowserProcessImpl::CreateSubresourceFilterRulesetService() {
   DCHECK(!subresource_filter_ruleset_service_);
   created_subresource_filter_ruleset_service_ = true;
--- a/chrome/browser/browser_process_impl.h
+++ b/chrome/browser/browser_process_impl.h
@@ -165,9 +165,6 @@ class BrowserProcessImpl : public Browse
   void set_background_mode_manager_for_test(
       std::unique_ptr<BackgroundModeManager> manager) override;
   StatusTray* status_tray() override;
-  safe_browsing::SafeBrowsingService* safe_browsing_service() override;
-  safe_browsing::ClientSideDetectionService* safe_browsing_detection_service()
-      override;
   subresource_filter::RulesetService* subresource_filter_ruleset_service()
       override;
   optimization_guide::OptimizationGuideService* optimization_guide_service()
@@ -308,9 +305,6 @@ class BrowserProcessImpl : public Browse
   std::unique_ptr<BackgroundModeManager> background_mode_manager_;
 #endif
 
-  bool created_safe_browsing_service_ = false;
-  scoped_refptr<safe_browsing::SafeBrowsingService> safe_browsing_service_;
-
   bool created_subresource_filter_ruleset_service_ = false;
   std::unique_ptr<subresource_filter::RulesetService>
       subresource_filter_ruleset_service_;
--- a/chrome/browser/browser_resources.grd
+++ b/chrome/browser/browser_resources.grd
@@ -152,9 +152,7 @@
       <include name="IDR_DOMAIN_RELIABILITY_INTERNALS_HTML" file="resources\domain_reliability_internals\domain_reliability_internals.html" compress="gzip" type="BINDATA" />
       <include name="IDR_DOMAIN_RELIABILITY_INTERNALS_CSS" file="resources\domain_reliability_internals\domain_reliability_internals.css" compress="gzip" type="BINDATA" />
       <include name="IDR_DOMAIN_RELIABILITY_INTERNALS_JS" file="resources\domain_reliability_internals\domain_reliability_internals.js" compress="gzip" type="BINDATA" />
-      <if expr="safe_browsing_mode != 0">
-        <include name="IDR_DOWNLOAD_FILE_TYPES_PB" file="${root_gen_dir}\chrome\browser\resources\safe_browsing\download_file_types.pb" use_base_dir="false" type="BINDATA" />
-      </if>
+      <include name="IDR_DOWNLOAD_FILE_TYPES_PB" file="${root_gen_dir}\chrome\browser\resources\safe_browsing\download_file_types.pb" use_base_dir="false" type="BINDATA" />
       <include name="IDR_DOWNLOAD_INTERNALS_HTML" file="resources\download_internals\download_internals.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" compress="gzip" />
       <include name="IDR_DOWNLOAD_INTERNALS_CSS" file="resources\download_internals\download_internals.css" type="BINDATA" compress="gzip" />
       <include name="IDR_DOWNLOAD_INTERNALS_JS" file="resources\download_internals\download_internals.js" type="BINDATA" compress="gzip" />
--- a/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc
+++ b/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc
@@ -256,17 +256,6 @@ bool DoesOriginMatchEmbedderMask(int ori
   return false;
 }
 
-// Callback for when cookies have been deleted. Invokes NotifyIfDone.
-// Receiving |cookie_manager| as a parameter so that the receive pipe is
-// not deleted before the response is received.
-void OnClearedCookies(
-    base::OnceClosure done,
-    mojo::Remote<network::mojom::CookieManager> cookie_manager,
-    uint32_t num_deleted) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  std::move(done).Run();
-}
-
 }  // namespace
 
 ChromeBrowsingDataRemoverDelegate::ChromeBrowsingDataRemoverDelegate(
@@ -662,36 +651,6 @@ void ChromeBrowsingDataRemoverDelegate::
         CONTENT_SETTINGS_TYPE_CLIENT_HINTS, base::Time(), base::Time::Max(),
         website_settings_filter);
 
-    // Clear the safebrowsing cookies only if time period is for "all time".  It
-    // doesn't make sense to apply the time period of deleting in the last X
-    // hours/days to the safebrowsing cookies since they aren't the result of
-    // any user action.
-    if (IsForAllTime()) {
-      safe_browsing::SafeBrowsingService* sb_service =
-          g_browser_process->safe_browsing_service();
-      if (sb_service) {
-        mojo::Remote<network::mojom::CookieManager> cookie_manager;
-        sb_service->GetNetworkContext()->GetCookieManager(
-            cookie_manager.BindNewPipeAndPassReceiver());
-
-        network::mojom::CookieManager* manager_ptr = cookie_manager.get();
-
-        network::mojom::CookieDeletionFilterPtr deletion_filter =
-            filter_builder->BuildCookieDeletionFilter();
-        if (!delete_begin_.is_null())
-          deletion_filter->created_after_time = delete_begin_;
-        if (!delete_end_.is_null())
-          deletion_filter->created_before_time = delete_end_;
-
-        manager_ptr->DeleteCookies(
-            std::move(deletion_filter),
-            base::BindOnce(
-                &OnClearedCookies,
-                CreateTaskCompletionClosure(TracingDataType::kCookies),
-                std::move(cookie_manager)));
-      }
-    }
-
     MediaDeviceIDSalt::Reset(profile_->GetPrefs());
   }
 
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -836,30 +836,6 @@ void SetApplicationLocaleOnIOThread(cons
   GetIOThreadApplicationLocale() = locale;
 }
 
-// An implementation of the SSLCertReporter interface used by
-// SSLErrorHandler. Uses CertificateReportingService to send reports. The
-// service handles queueing and re-sending of failed reports. Each certificate
-// error creates a new instance of this class.
-class CertificateReportingServiceCertReporter : public SSLCertReporter {
- public:
-  explicit CertificateReportingServiceCertReporter(
-      content::WebContents* web_contents)
-      : service_(CertificateReportingServiceFactory::GetForBrowserContext(
-            web_contents->GetBrowserContext())) {}
-  ~CertificateReportingServiceCertReporter() override {}
-
-  // SSLCertReporter implementation
-  void ReportInvalidCertificateChain(
-      const std::string& serialized_report) override {
-    service_->Send(serialized_report);
-  }
-
- private:
-  CertificateReportingService* service_;
-
-  DISALLOW_COPY_AND_ASSIGN(CertificateReportingServiceCertReporter);
-};
-
 #if defined(OS_ANDROID)
 float GetDeviceScaleAdjustment() {
   static const float kMinFSM = 1.05f;
@@ -1245,9 +1221,6 @@ void ChromeContentBrowserClient::PostAft
   AfterStartupTaskUtils::PostTask(from_here, task_runner, std::move(task));
 
   InitNetworkContextsParentDirectory();
-
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  safe_browsing_service_ = g_browser_process->safe_browsing_service();
 }
 
 bool ChromeContentBrowserClient::IsBrowserStartupComplete() {
@@ -2050,7 +2023,7 @@ void ChromeContentBrowserClient::AppendE
       // Disable client-side phishing detection in the renderer if it is
       // disabled in the Profile preferences or the browser process.
       if (!prefs->GetBoolean(prefs::kSafeBrowsingEnabled) ||
-          !g_browser_process->safe_browsing_detection_service()) {
+          true) {
         command_line->AppendSwitch(
             switches::kDisableClientSidePhishingDetection);
       }
@@ -3924,7 +3897,7 @@ ChromeContentBrowserClient::CreateThrott
 
   throttles.push_back(std::make_unique<SSLErrorNavigationThrottle>(
       handle,
-      std::make_unique<CertificateReportingServiceCertReporter>(web_contents),
+      nullptr,
       base::Bind(&SSLErrorHandler::HandleSSLError)));
 
   throttles.push_back(std::make_unique<LoginNavigationThrottle>(handle));
@@ -3945,12 +3918,6 @@ ChromeContentBrowserClient::CreateThrott
       GooglePasswordManagerNavigationThrottle::MaybeCreateThrottleFor(handle));
 #endif
 
-  if (base::FeatureList::IsEnabled(safe_browsing::kCommittedSBInterstitials)) {
-    throttles.push_back(
-        std::make_unique<safe_browsing::SafeBrowsingNavigationThrottle>(
-            handle));
-  }
-
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
   MaybeAddThrottle(&throttles,
@@ -4906,19 +4873,7 @@ ChromeContentBrowserClient::GetSafeBrows
     content::ResourceContext* resource_context) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
-  ProfileIOData* io_data = ProfileIOData::FromResourceContext(resource_context);
-  if (!io_data->safe_browsing_enabled()->GetValue())
-    return nullptr;
-
-  // |safe_browsing_service_| may be unavailable in tests.
-  if (safe_browsing_service_ && !safe_browsing_url_checker_delegate_) {
-    safe_browsing_url_checker_delegate_ =
-        base::MakeRefCounted<safe_browsing::UrlCheckerDelegateImpl>(
-            safe_browsing_service_->database_manager(),
-            safe_browsing_service_->ui_manager());
-  }
-
-  return safe_browsing_url_checker_delegate_;
+  return nullptr;
 }
 
 base::Optional<std::string>
--- a/chrome/browser/component_updater/file_type_policies_component_installer.cc
+++ b/chrome/browser/component_updater/file_type_policies_component_installer.cc
@@ -38,20 +38,6 @@ const uint8_t kFileTypePoliciesPublicKey
 const char kFileTypePoliciesManifestName[] = "File Type Policies";
 
 void LoadFileTypesFromDisk(const base::FilePath& pb_path) {
-  if (pb_path.empty())
-    return;
-
-  VLOG(1) << "Reading Download File Types from file: " << pb_path.value();
-  std::string binary_pb;
-  if (!base::ReadFileToString(pb_path, &binary_pb)) {
-    // The file won't exist on new installations, so this is not always an
-    // error.
-    VLOG(1) << "Failed reading from " << pb_path.value();
-    return;
-  }
-
-  safe_browsing::FileTypePolicies::GetInstance()->PopulateFromDynamicUpdate(
-      binary_pb);
 }
 
 }  // namespace
--- a/chrome/browser/download/chrome_download_manager_delegate.cc
+++ b/chrome/browser/download/chrome_download_manager_delegate.cc
@@ -39,9 +39,6 @@
 #include "chrome/browser/download/save_package_file_picker.h"
 #include "chrome/browser/platform_util.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/download_protection/binary_upload_service.h"
-#include "chrome/browser/safe_browsing/download_protection/download_protection_util.h"
-#include "chrome/browser/safe_browsing/safe_browsing_service.h"
 #include "chrome/browser/ui/chrome_pages.h"
 #include "chrome/browser/ui/scoped_tabbed_browser_displayer.h"
 #include "chrome/common/buildflags.h"
@@ -50,7 +47,6 @@
 #include "chrome/common/chrome_paths.h"
 #include "chrome/common/pdf_util.h"
 #include "chrome/common/pref_names.h"
-#include "chrome/common/safe_browsing/file_type_policies.h"
 #include "chrome/grit/generated_resources.h"
 #include "components/download/public/common/download_danger_type.h"
 #include "components/download/public/common/download_features.h"
@@ -115,8 +111,6 @@ using content::DownloadManager;
 using download::DownloadItem;
 using download::DownloadPathReservationTracker;
 using download::PathValidationResult;
-using safe_browsing::DownloadFileType;
-using safe_browsing::DownloadProtectionService;
 
 namespace {
 
@@ -310,13 +304,6 @@ ChromeDownloadManagerDelegate::~ChromeDo
 
 void ChromeDownloadManagerDelegate::SetDownloadManager(DownloadManager* dm) {
   download_manager_ = dm;
-
-  safe_browsing::SafeBrowsingService* sb_service =
-      g_browser_process->safe_browsing_service();
-  if (sb_service && !profile_->IsOffTheRecord()) {
-    // Include this download manager in the set monitored by safe browsing.
-    sb_service->AddDownloadManager(dm);
-  }
 }
 
 #if defined(OS_ANDROID)
@@ -626,16 +613,6 @@ void ChromeDownloadManagerDelegate::Choo
 
 void ChromeDownloadManagerDelegate::SanitizeSavePackageResourceName(
     base::FilePath* filename) {
-  safe_browsing::FileTypePolicies* file_type_policies =
-      safe_browsing::FileTypePolicies::GetInstance();
-
-  if (file_type_policies->GetFileDangerLevel(*filename) ==
-      safe_browsing::DownloadFileType::NOT_DANGEROUS)
-    return;
-
-  base::FilePath default_filename = base::FilePath::FromUTF8Unsafe(
-      l10n_util::GetStringUTF8(IDS_DEFAULT_DOWNLOAD_FILENAME));
-  *filename = filename->AddExtension(default_filename.BaseName().value());
 }
 
 void ChromeDownloadManagerDelegate::OpenDownloadUsingPlatformHandler(
@@ -759,20 +736,6 @@ ChromeDownloadManagerDelegate::Applicati
   return std::string(chrome::kApplicationClientIDStringForAVScanning);
 }
 
-DownloadProtectionService*
-    ChromeDownloadManagerDelegate::GetDownloadProtectionService() {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-#if BUILDFLAG(FULL_SAFE_BROWSING)
-  safe_browsing::SafeBrowsingService* sb_service =
-      g_browser_process->safe_browsing_service();
-  if (sb_service && sb_service->download_protection_service() &&
-      profile_->GetPrefs()->GetBoolean(prefs::kSafeBrowsingEnabled)) {
-    return sb_service->download_protection_service();
-  }
-#endif
-  return nullptr;
-}
-
 void ChromeDownloadManagerDelegate::ShouldBlockDownload(
     download::DownloadItem* download,
     const base::FilePath& virtual_path,
--- a/chrome/browser/download/chrome_download_manager_delegate.h
+++ b/chrome/browser/download/chrome_download_manager_delegate.h
@@ -22,11 +22,10 @@
 #include "chrome/browser/download/download_completion_blocker.h"
 #include "chrome/browser/download/download_target_determiner_delegate.h"
 #include "chrome/browser/download/download_target_info.h"
-#include "chrome/browser/safe_browsing/download_protection/download_protection_service.h"
-#include "chrome/browser/safe_browsing/download_protection/download_protection_util.h"
 #include "components/download/public/common/download_danger_type.h"
 #include "components/download/public/common/download_item.h"
 #include "components/download/public/common/download_path_reservation_tracker.h"
+#include "components/safe_browsing/buildflags.h"
 #include "content/public/browser/download_manager_delegate.h"
 #include "content/public/browser/notification_observer.h"
 #include "content/public/browser/notification_registrar.h"
@@ -151,8 +150,6 @@ class ChromeDownloadManagerDelegate
 #endif  // FULL_SAFE_BROWSING
 
  protected:
-  virtual safe_browsing::DownloadProtectionService*
-      GetDownloadProtectionService();
 
   // Show file picker for |download|.
   virtual void ShowFilePickerForDownload(
@@ -221,10 +218,6 @@ class ChromeDownloadManagerDelegate
                const content::NotificationSource& source,
                const content::NotificationDetails& details) override;
 
-  // Callback function after the DownloadProtectionService completes.
-  void CheckClientDownloadDone(uint32_t download_id,
-                               safe_browsing::DownloadCheckResult result);
-
   // Internal gateways for ShouldCompleteDownload().
   bool IsDownloadReadyForCompletion(
       download::DownloadItem* item,
--- a/chrome/browser/download/download_item_model.cc
+++ b/chrome/browser/download/download_item_model.cc
@@ -23,9 +23,6 @@
 #include "chrome/browser/download/download_stats.h"
 #include "chrome/browser/download/offline_item_utils.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/download_protection/download_feedback_service.h"
-#include "chrome/common/safe_browsing/download_file_types.pb.h"
-#include "chrome/common/safe_browsing/file_type_policies.h"
 #include "chrome/grit/chromium_strings.h"
 #include "chrome/grit/generated_resources.h"
 #include "components/download/public/common/download_danger_type.h"
@@ -546,9 +543,6 @@ bool DownloadItemModel::IsCommandEnabled
       // filename. Don't base an "Always open" decision based on it. Also
       // exclude extensions.
       return download_->CanOpenDownload() &&
-             safe_browsing::FileTypePolicies::GetInstance()
-                 ->IsAllowedToOpenAutomatically(
-                     download_->GetTargetFilePath()) &&
              !download_crx_util::IsExtensionDownload(*download_);
     case DownloadCommands::PAUSE:
       return !download_->IsSavePackageDownload() &&
--- a/chrome/browser/download/download_prefs.cc
+++ b/chrome/browser/download/download_prefs.cc
@@ -228,14 +228,7 @@ DownloadPrefs::DownloadPrefs(Profile* pr
         base::FilePath::StringType(1, base::FilePath::kExtensionSeparator) +
         extension);
 
-    // Note that the list of file types that are not allowed to open
-    // automatically can change in the future. When the list is tightened, it is
-    // expected that some entries in the users' auto open list will get dropped
-    // permanently as a result.
-    if (FileTypePolicies::GetInstance()->IsAllowedToOpenAutomatically(
-            filename_with_extension)) {
-      auto_open_.insert(extension);
-    }
+    auto_open_.insert(extension);
   }
 }
 
@@ -385,10 +378,6 @@ bool DownloadPrefs::IsAutoOpenEnabledBas
 bool DownloadPrefs::EnableAutoOpenBasedOnExtension(
     const base::FilePath& file_name) {
   base::FilePath::StringType extension = file_name.Extension();
-  if (!FileTypePolicies::GetInstance()->IsAllowedToOpenAutomatically(
-          file_name)) {
-    return false;
-  }
 
   DCHECK(extension[0] == base::FilePath::kExtensionSeparator);
   extension.erase(0, 1);
--- a/chrome/browser/download/download_target_determiner.cc
+++ b/chrome/browser/download/download_target_determiner.cc
@@ -258,9 +258,7 @@ DownloadTargetDeterminer::Result
     // considered safe by safe browsing. Noticed that when generating file name,
     // |suggested_filename| and Content-Disposition header have higher priority
     // than the URL.
-    bool safe_file_ext =
-        !safe_browsing::FileTypePolicies::GetInstance()->IsCheckedBinaryFile(
-            generated_filename);
+    bool safe_file_ext = true;
     net::HttpContentDisposition content_disposition_header(
         download_->GetContentDisposition(), referrer_charset);
     bool should_replace_extension =
@@ -1063,29 +1061,7 @@ DownloadFileType::DangerLevel DownloadTa
       download_->HasUserGesture())
     return DownloadFileType::NOT_DANGEROUS;
 
-  DownloadFileType::DangerLevel danger_level =
-      safe_browsing::FileTypePolicies::GetInstance()->GetFileDangerLevel(
-          virtual_path_.BaseName());
-
-  // A danger level of ALLOW_ON_USER_GESTURE is used to label potentially
-  // dangerous file types that have a high frequency of legitimate use. We would
-  // like to avoid prompting for the legitimate cases as much as possible. To
-  // that end, we consider a download to be legitimate if one of the following
-  // is true, and avoid prompting:
-  //
-  // * The user navigated to the download URL via the omnibox (either by typing
-  //   the URL, pasting it, or using search).
-  //
-  // * The navigation that initiated the download has a user gesture associated
-  //   with it AND the user the user is familiar with the referring origin. A
-  //   user is considered familiar with a referring origin if a visit for a page
-  //   from the same origin was recorded on the previous day or earlier.
-  if (danger_level == DownloadFileType::ALLOW_ON_USER_GESTURE &&
-      ((download_->GetTransitionType() &
-        ui::PAGE_TRANSITION_FROM_ADDRESS_BAR) != 0 ||
-       (download_->HasUserGesture() && visits == VISITED_REFERRER)))
-    return DownloadFileType::NOT_DANGEROUS;
-  return danger_level;
+  return DownloadFileType::NOT_DANGEROUS;
 }
 
 void DownloadTargetDeterminer::OnDownloadDestroyed(
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -304,10 +304,6 @@ jumbo_static_library("extensions") {
     "api/runtime/chrome_runtime_api_delegate.h",
     "api/safe_browsing_private/safe_browsing_private_api.cc",
     "api/safe_browsing_private/safe_browsing_private_api.h",
-    "api/safe_browsing_private/safe_browsing_private_event_router.cc",
-    "api/safe_browsing_private/safe_browsing_private_event_router.h",
-    "api/safe_browsing_private/safe_browsing_private_event_router_factory.cc",
-    "api/safe_browsing_private/safe_browsing_private_event_router_factory.h",
     "api/safe_browsing_private/safe_browsing_util.cc",
     "api/safe_browsing_private/safe_browsing_util.h",
     "api/sessions/session_id.cc",
@@ -747,9 +743,6 @@ jumbo_static_library("extensions") {
 
     # TODO(loyso): Remove this circular dependency. http://crbug.com/876576.
     "//chrome/browser/web_applications/extensions",
-
-    # TODO(crbug/925153): Remove this circular dependency.
-    "//chrome/browser/safe_browsing",
   ]
 
   # Since browser and browser_extensions actually depend on each other,
@@ -761,9 +754,6 @@ jumbo_static_library("extensions") {
     "//chrome/browser/extensions/api:api_registration",
     "//chrome/common",
     "//chrome/common/extensions/api",
-    "//components/safe_browsing:csd_proto",
-    "//components/safe_browsing:webprotect_proto",
-    "//components/safe_browsing/db:util",
     "//components/signin/core/browser",
     "//content/public/browser",
     "//mojo/public/cpp/bindings",
@@ -785,11 +775,9 @@ jumbo_static_library("extensions") {
     "//chrome/browser/media/router",
     "//chrome/browser/media/router/discovery",
     "//chrome/browser/resource_coordinator:mojo_bindings",
-    "//chrome/browser/safe_browsing",
     "//chrome/browser/web_applications/components",
     "//chrome/browser/web_applications/extensions",
     "//chrome/common/extensions/api:extensions_features",
-    "//chrome/common/safe_browsing:proto",
     "//chrome/services/removable_storage_writer/public/mojom",
     "//components/app_modal",
     "//components/autofill/content/browser",
@@ -832,10 +820,6 @@ jumbo_static_library("extensions") {
     "//components/rappor",
     "//components/resources",
     "//components/safe_browsing:buildflags",
-    "//components/safe_browsing:csd_proto",
-    "//components/safe_browsing:features",
-    "//components/safe_browsing/common:safe_browsing_prefs",
-    "//components/safe_browsing/db:database_manager",
     "//components/search_engines",
     "//components/services/patch/content",
     "//components/services/unzip/content",
--- a/chrome/browser/extensions/api/downloads/downloads_api.cc
+++ b/chrome/browser/extensions/api/downloads/downloads_api.cc
@@ -38,7 +38,6 @@
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/download/download_core_service.h"
 #include "chrome/browser/download/download_core_service_factory.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/download/download_file_icon_extractor.h"
 #include "chrome/browser/download/download_open_prompt.h"
 #include "chrome/browser/download/download_prefs.h"
@@ -1325,9 +1324,6 @@ DownloadsAcceptDangerFunction::Downloads
 
 DownloadsAcceptDangerFunction::~DownloadsAcceptDangerFunction() {}
 
-DownloadsAcceptDangerFunction::OnPromptCreatedCallback*
-    DownloadsAcceptDangerFunction::on_prompt_created_ = NULL;
-
 bool DownloadsAcceptDangerFunction::RunAsync() {
   std::unique_ptr<downloads::AcceptDanger::Params> params(
       downloads::AcceptDanger::Params::Create(*args_));
@@ -1365,40 +1361,7 @@ void DownloadsAcceptDangerFunction::Prom
     return;
   }
   RecordApiFunctions(DOWNLOADS_FUNCTION_ACCEPT_DANGER);
-  // DownloadDangerPrompt displays a modal dialog using native widgets that the
-  // user must either accept or cancel. It cannot be scripted.
-  DownloadDangerPrompt* prompt = DownloadDangerPrompt::Create(
-      download_item,
-      web_contents,
-      true,
-      base::Bind(&DownloadsAcceptDangerFunction::DangerPromptCallback,
-                 this, download_id));
-  // DownloadDangerPrompt deletes itself
-  if (on_prompt_created_ && !on_prompt_created_->is_null())
-    on_prompt_created_->Run(prompt);
-  // Function finishes in DangerPromptCallback().
-}
-
-void DownloadsAcceptDangerFunction::DangerPromptCallback(
-    int download_id, DownloadDangerPrompt::Action action) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  DownloadItem* download_item = GetDownload(
-      browser_context(), include_incognito_information(), download_id);
-  if (InvalidId(download_item, &error_) ||
-      Fault(download_item->GetState() != DownloadItem::IN_PROGRESS,
-            download_extension_errors::kNotInProgress, &error_))
-    return;
-  switch (action) {
-    case DownloadDangerPrompt::ACCEPT:
-      download_item->ValidateDangerousDownload();
-      break;
-    case DownloadDangerPrompt::CANCEL:
-      download_item->Remove();
-      break;
-    case DownloadDangerPrompt::DISMISS:
-      break;
-  }
-  SendResponse(error_.empty());
+  download_item->ValidateDangerousDownload();
 }
 
 DownloadsShowFunction::DownloadsShowFunction() {}
--- a/chrome/browser/extensions/api/downloads/downloads_api.h
+++ b/chrome/browser/extensions/api/downloads/downloads_api.h
@@ -13,7 +13,6 @@
 #include "base/macros.h"
 #include "base/scoped_observer.h"
 #include "base/time/time.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/extensions/chrome_extension_function.h"
 #include "chrome/common/extensions/api/downloads.h"
 #include "components/download/content/public/all_download_item_notifier.h"
@@ -186,25 +185,16 @@ class DownloadsRemoveFileFunction : publ
 
 class DownloadsAcceptDangerFunction : public ChromeAsyncExtensionFunction {
  public:
-  typedef base::Callback<void(DownloadDangerPrompt*)> OnPromptCreatedCallback;
-  static void OnPromptCreatedForTesting(
-      OnPromptCreatedCallback* callback) {
-    on_prompt_created_ = callback;
-  }
-
   DECLARE_EXTENSION_FUNCTION("downloads.acceptDanger", DOWNLOADS_ACCEPTDANGER)
   DownloadsAcceptDangerFunction();
   bool RunAsync() override;
 
  protected:
   ~DownloadsAcceptDangerFunction() override;
-  void DangerPromptCallback(int download_id,
-                            DownloadDangerPrompt::Action action);
 
  private:
   void PromptOrWait(int download_id, int retries);
 
-  static OnPromptCreatedCallback* on_prompt_created_;
   DISALLOW_COPY_AND_ASSIGN(DownloadsAcceptDangerFunction);
 };
 
--- a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_api.cc
+++ b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_api.cc
@@ -52,37 +52,7 @@ SafeBrowsingPrivateGetReferrerChainFunct
         base::StringPrintf("Could not find tab with id %d.", params->tab_id)));
   }
 
-  Profile* profile = Profile::FromBrowserContext(browser_context());
-  if (!SafeBrowsingNavigationObserverManager::IsEnabledAndReady(profile))
-    return RespondNow(NoArguments());
-
-  scoped_refptr<SafeBrowsingNavigationObserverManager>
-      navigation_observer_manager = g_browser_process->safe_browsing_service()
-                                        ->navigation_observer_manager();
-
-  safe_browsing::ReferrerChain referrer_chain;
-  SafeBrowsingNavigationObserverManager::AttributionResult result =
-      navigation_observer_manager->IdentifyReferrerChainByWebContents(
-          contents, kReferrerUserGestureLimit, &referrer_chain);
-
-  // If the referrer chain is incomplete we'll append the most recent
-  // navigations to referrer chain for diagnostic purposes. This only happens if
-  // the user is not in incognito mode and has opted into extended reporting or
-  // Scout reporting. Otherwise, |CountOfRecentNavigationsToAppend| returns 0.
-  int recent_navigations_to_collect =
-      SafeBrowsingNavigationObserverManager::CountOfRecentNavigationsToAppend(
-          *profile, result);
-  if (recent_navigations_to_collect > 0) {
-    navigation_observer_manager->AppendRecentNavigations(
-        recent_navigations_to_collect, &referrer_chain);
-  }
-
   std::vector<api::safe_browsing_private::ReferrerChainEntry> referrer_entries;
-  referrer_entries.reserve(referrer_chain.size());
-  for (const auto& entry : referrer_chain) {
-    referrer_entries.emplace_back(
-        safe_browsing_util::ReferrerToReferrerChainEntry(entry));
-  }
   return RespondNow(ArgumentList(
       api::safe_browsing_private::GetReferrerChain::Results::Create(
           referrer_entries)));
--- a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
+++ b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
@@ -411,6 +411,7 @@ void SafeBrowsingPrivateEventRouter::Set
 }
 
 void SafeBrowsingPrivateEventRouter::InitRealtimeReportingClient() {
+  return;
 #if !defined(OS_CHROMEOS)
   // If already initialized, do nothing.
   if (client_)
--- a/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc
+++ b/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc
@@ -683,51 +683,9 @@ WebstorePrivateGetReferrerChainFunction:
 
 ExtensionFunction::ResponseAction
 WebstorePrivateGetReferrerChainFunction::Run() {
-  Profile* profile = chrome_details_.GetProfile();
-  if (!SafeBrowsingNavigationObserverManager::IsEnabledAndReady(profile))
-    return RespondNow(ArgumentList(
-        api::webstore_private::GetReferrerChain::Results::Create("")));
-
-  content::WebContents* web_contents = GetSenderWebContents();
-  if (!web_contents) {
-    return RespondNow(ErrorWithArguments(
-        api::webstore_private::GetReferrerChain::Results::Create(""),
-        kWebstoreUserCancelledError));
-  }
-
-  scoped_refptr<SafeBrowsingNavigationObserverManager>
-      navigation_observer_manager = g_browser_process->safe_browsing_service()
-                                        ->navigation_observer_manager();
-
-  safe_browsing::ReferrerChain referrer_chain;
-  SafeBrowsingNavigationObserverManager::AttributionResult result =
-      navigation_observer_manager->IdentifyReferrerChainByWebContents(
-          web_contents, kExtensionReferrerUserGestureLimit, &referrer_chain);
-
-  // If the referrer chain is incomplete we'll append the most recent
-  // navigations to referrer chain for diagnostic purposes. This only happens if
-  // the user is not in incognito mode and has opted into extended reporting or
-  // Scout reporting. Otherwise, |CountOfRecentNavigationsToAppend| returns 0.
-  int recent_navigations_to_collect =
-      SafeBrowsingNavigationObserverManager::CountOfRecentNavigationsToAppend(
-          *profile, result);
-  if (recent_navigations_to_collect > 0) {
-    navigation_observer_manager->AppendRecentNavigations(
-        recent_navigations_to_collect, &referrer_chain);
-  }
-
-  safe_browsing::ExtensionWebStoreInstallRequest request;
-  request.mutable_referrer_chain()->Swap(&referrer_chain);
-  request.mutable_referrer_chain_options()->set_recent_navigations_to_collect(
-      recent_navigations_to_collect);
-
-  std::string serialized_referrer_proto = request.SerializeAsString();
-  // Base64 encode the proto to avoid issues with base::Value rejecting strings
-  // which are not valid UTF8.
-  base::Base64Encode(serialized_referrer_proto, &serialized_referrer_proto);
   return RespondNow(
       ArgumentList(api::webstore_private::GetReferrerChain::Results::Create(
-          serialized_referrer_proto)));
+          "")));
 }
 
 }  // namespace extensions
--- a/chrome/browser/extensions/blacklist_state_fetcher.cc
+++ b/chrome/browser/extensions/blacklist_state_fetcher.cc
@@ -32,90 +32,11 @@ BlacklistStateFetcher::~BlacklistStateFe
 void BlacklistStateFetcher::Request(const std::string& id,
                                     const RequestCallback& callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  if (!safe_browsing_config_) {
-    if (g_browser_process && g_browser_process->safe_browsing_service()) {
-      SetSafeBrowsingConfig(
-          g_browser_process->safe_browsing_service()->GetV4ProtocolConfig());
-    } else {
-      base::ThreadTaskRunnerHandle::Get()->PostTask(
-          FROM_HERE, base::BindOnce(callback, BLACKLISTED_UNKNOWN));
-      return;
-    }
-  }
-
-  bool request_already_sent = base::Contains(callbacks_, id);
-  callbacks_.insert(std::make_pair(id, callback));
-  if (request_already_sent)
-    return;
-
-  if (g_browser_process && g_browser_process->safe_browsing_service()) {
-    url_loader_factory_ =
-        g_browser_process->safe_browsing_service()->GetURLLoaderFactory();
-  }
-
-  SendRequest(id);
+  base::ThreadTaskRunnerHandle::Get()->PostTask(
+      FROM_HERE, base::BindOnce(callback, BLACKLISTED_UNKNOWN));
 }
 
 void BlacklistStateFetcher::SendRequest(const std::string& id) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  ClientCRXListInfoRequest request;
-  request.set_id(id);
-  std::string request_str;
-  request.SerializeToString(&request_str);
-
-  GURL request_url = GURL(safe_browsing::GetReportUrl(
-      *safe_browsing_config_, "clientreport/crx-list-info"));
-  net::NetworkTrafficAnnotationTag traffic_annotation =
-      net::DefineNetworkTrafficAnnotation("extension_blacklist", R"(
-        semantics {
-          sender: "Extension Blacklist"
-          description:
-            "Chromium protects the users from malicious extensions by checking "
-            "extensions that are being installed or have been installed "
-            "against a list of known malwares. Chromium sends the identifiers "
-            "of extensions to Google and Google responds with whether it "
-            "believes each extension is malware or not. Only extensions that "
-            "match the safe browsing blacklist can trigger this request."
-          trigger:
-            "When extensions are being installed and at startup when existing "
-            "extensions are scanned."
-          data: "The identifier of the installed extension."
-          destination: GOOGLE_OWNED_SERVICE
-        }
-        policy {
-          cookies_allowed: YES
-          cookies_store: "Safe Browsing cookies store"
-          setting:
-            "Users can enable or disable this feature by toggling 'Protect you "
-            "and your device from dangerous sites' in Chromium settings under "
-            "Privacy. This feature is enabled by default."
-          chrome_policy {
-            SafeBrowsingEnabled {
-              policy_options {mode: MANDATORY}
-              SafeBrowsingEnabled: false
-            }
-          }
-        })");
-  auto resource_request = std::make_unique<network::ResourceRequest>();
-  resource_request->url = request_url;
-  resource_request->method = "POST";
-  std::unique_ptr<network::SimpleURLLoader> fetcher_ptr =
-      network::SimpleURLLoader::Create(std::move(resource_request),
-                                       traffic_annotation);
-  auto* fetcher = fetcher_ptr.get();
-  fetcher->AttachStringForUpload(request_str, "application/octet-stream");
-  requests_[fetcher] = {std::move(fetcher_ptr), id};
-  fetcher->DownloadToStringOfUnboundedSizeUntilCrashAndDie(
-      url_loader_factory_.get(),
-      base::BindOnce(&BlacklistStateFetcher::OnURLLoaderComplete,
-                     base::Unretained(this), fetcher));
-}
-
-void BlacklistStateFetcher::SetSafeBrowsingConfig(
-    const safe_browsing::V4ProtocolConfig& config) {
-  safe_browsing_config_ =
-      std::make_unique<safe_browsing::V4ProtocolConfig>(config);
 }
 
 void BlacklistStateFetcher::OnURLLoaderComplete(
@@ -151,26 +72,7 @@ void BlacklistStateFetcher::OnURLLoaderC
   std::string id = it->second.second;
   requests_.erase(it);
 
-  BlacklistState state;
-  if (net_error == net::OK && response_code == 200) {
-    ClientCRXListInfoResponse response;
-    if (response.ParseFromString(response_body)) {
-      state = static_cast<BlacklistState>(response.verdict());
-    } else {
-      state = BLACKLISTED_UNKNOWN;
-    }
-  } else {
-    if (net_error != net::OK) {
-      VLOG(1) << "Blacklist request for: " << id
-              << " failed with error: " << net_error;
-    } else {
-      VLOG(1) << "Blacklist request for: " << id
-              << " failed with error: " << response_code;
-    }
-
-    state = BLACKLISTED_UNKNOWN;
-  }
-
+  BlacklistState state = BLACKLISTED_UNKNOWN;
   std::pair<CallbackMultiMap::iterator, CallbackMultiMap::iterator> range =
       callbacks_.equal_range(id);
   for (CallbackMultiMap::const_iterator callback_it = range.first;
--- a/chrome/browser/extensions/blacklist_state_fetcher.h
+++ b/chrome/browser/extensions/blacklist_state_fetcher.h
@@ -34,8 +34,6 @@ class BlacklistStateFetcher {
 
   virtual void Request(const std::string& id, const RequestCallback& callback);
 
-  void SetSafeBrowsingConfig(const safe_browsing::V4ProtocolConfig& config);
-
  protected:
   void OnURLLoaderComplete(network::SimpleURLLoader* url_loader,
                            std::unique_ptr<std::string> response_body);
@@ -54,7 +52,6 @@ class BlacklistStateFetcher {
 
   void SendRequest(const std::string& id);
 
-  std::unique_ptr<safe_browsing::V4ProtocolConfig> safe_browsing_config_;
   scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory_;
 
   // SimpleURLLoader -> (owned loader, extension id).
--- a/chrome/browser/interstitials/enterprise_util.cc
+++ b/chrome/browser/interstitials/enterprise_util.cc
@@ -12,22 +12,6 @@
 
 namespace {
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
-extensions::SafeBrowsingPrivateEventRouter* GetEventRouter(
-    content::WebContents* web_contents) {
-  // |web_contents| can be null in tests.
-  if (!web_contents)
-    return nullptr;
-
-  content::BrowserContext* browser_context = web_contents->GetBrowserContext();
-  if (browser_context->IsOffTheRecord())
-    return nullptr;
-
-  return extensions::SafeBrowsingPrivateEventRouterFactory::GetForProfile(
-      browser_context);
-}
-#endif  // BUILDFLAG(ENABLE_EXTENSIONS)
-
 }  // namespace
 
 void MaybeTriggerSecurityInterstitialShownEvent(
@@ -35,13 +19,6 @@ void MaybeTriggerSecurityInterstitialSho
     const GURL& page_url,
     const std::string& reason,
     int net_error_code) {
-#if BUILDFLAG(ENABLE_EXTENSIONS)
-  extensions::SafeBrowsingPrivateEventRouter* event_router =
-      GetEventRouter(web_contents);
-  if (!event_router)
-    return;
-  event_router->OnSecurityInterstitialShown(page_url, reason, net_error_code);
-#endif
 }
 
 void MaybeTriggerSecurityInterstitialProceededEvent(
@@ -49,14 +26,6 @@ void MaybeTriggerSecurityInterstitialPro
     const GURL& page_url,
     const std::string& reason,
     int net_error_code) {
-#if BUILDFLAG(ENABLE_EXTENSIONS)
-  extensions::SafeBrowsingPrivateEventRouter* event_router =
-      GetEventRouter(web_contents);
-  if (!event_router)
-    return;
-  event_router->OnSecurityInterstitialProceeded(page_url, reason,
-                                                net_error_code);
-#endif
 }
 
 std::string GetThreatTypeStringForInterstitial(
--- a/chrome/browser/native_file_system/chrome_native_file_system_permission_context.cc
+++ b/chrome/browser/native_file_system/chrome_native_file_system_permission_context.cc
@@ -18,7 +18,6 @@
 #include "chrome/browser/native_file_system/native_file_system_permission_context_factory.h"
 #include "chrome/browser/native_file_system/native_file_system_permission_request_manager.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/download_protection/download_protection_service.h"
 #include "chrome/browser/sessions/session_tab_helper.h"
 #include "chrome/browser/ui/browser_dialogs.h"
 #include "chrome/common/chrome_paths.h"
@@ -328,75 +327,6 @@ class ReadPermissionGrantImpl
   PermissionStatus status_ = PermissionStatus::GRANTED;
 };
 
-void DoSafeBrowsingCheckOnUIThread(
-    int process_id,
-    int frame_id,
-    std::unique_ptr<content::NativeFileSystemWriteItem> item,
-    safe_browsing::CheckDownloadCallback callback) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  safe_browsing::SafeBrowsingService* sb_service =
-      g_browser_process->safe_browsing_service();
-
-  if (!sb_service || !sb_service->download_protection_service() ||
-      !sb_service->download_protection_service()->enabled()) {
-    std::move(callback).Run(safe_browsing::DownloadCheckResult::UNKNOWN);
-    return;
-  }
-
-  if (!item->browser_context) {
-    content::RenderProcessHost* rph =
-        content::RenderProcessHost::FromID(process_id);
-    if (!rph) {
-      std::move(callback).Run(safe_browsing::DownloadCheckResult::UNKNOWN);
-      return;
-    }
-    item->browser_context = rph->GetBrowserContext();
-  }
-
-  if (!item->web_contents) {
-    content::RenderFrameHost* rfh =
-        content::RenderFrameHost::FromID(process_id, frame_id);
-    if (rfh)
-      item->web_contents = content::WebContents::FromRenderFrameHost(rfh);
-  }
-
-  sb_service->download_protection_service()->CheckNativeFileSystemWrite(
-      std::move(item), std::move(callback));
-}
-
-ChromeNativeFileSystemPermissionContext::AfterWriteCheckResult
-InterpretSafeBrowsingResult(safe_browsing::DownloadCheckResult result) {
-  using Result = safe_browsing::DownloadCheckResult;
-  switch (result) {
-    // Only allow downloads that are marked as SAFE or UNKNOWN by SafeBrowsing.
-    // All other types are going to be blocked. UNKNOWN could be the result of a
-    // failed safe browsing ping.
-    case Result::UNKNOWN:
-    case Result::SAFE:
-    case Result::WHITELISTED_BY_POLICY:
-      return ChromeNativeFileSystemPermissionContext::AfterWriteCheckResult::
-          kAllow;
-
-    case Result::DANGEROUS:
-    case Result::UNCOMMON:
-    case Result::DANGEROUS_HOST:
-    case Result::POTENTIALLY_UNWANTED:
-    case Result::BLOCKED_PASSWORD_PROTECTED:
-    case Result::BLOCKED_TOO_LARGE:
-      return ChromeNativeFileSystemPermissionContext::AfterWriteCheckResult::
-          kBlock;
-
-    // This shouldn't be returned for Native File System write checks.
-    case Result::ASYNC_SCANNING:
-      NOTREACHED();
-      return ChromeNativeFileSystemPermissionContext::AfterWriteCheckResult::
-          kAllow;
-  }
-  NOTREACHED();
-  return ChromeNativeFileSystemPermissionContext::AfterWriteCheckResult::kBlock;
-}
-
 }  // namespace
 
 ChromeNativeFileSystemPermissionContext::Grants::Grants() = default;
@@ -682,22 +612,6 @@ void ChromeNativeFileSystemPermissionCon
     int process_id,
     int frame_id,
     base::OnceCallback<void(AfterWriteCheckResult)> callback) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  base::PostTask(
-      FROM_HERE, {content::BrowserThread::UI},
-      base::BindOnce(
-          &DoSafeBrowsingCheckOnUIThread, process_id, frame_id, std::move(item),
-          base::BindOnce(
-              [](scoped_refptr<base::TaskRunner> task_runner,
-                 base::OnceCallback<void(AfterWriteCheckResult result)>
-                     callback,
-                 safe_browsing::DownloadCheckResult result) {
-                task_runner->PostTask(
-                    FROM_HERE,
-                    base::BindOnce(std::move(callback),
-                                   InterpretSafeBrowsingResult(result)));
-              },
-              base::SequencedTaskRunnerHandle::Get(), std::move(callback))));
 }
 
 ChromeNativeFileSystemPermissionContext::Grants
--- a/chrome/browser/net/trial_comparison_cert_verifier_controller.cc
+++ b/chrome/browser/net/trial_comparison_cert_verifier_controller.cc
@@ -127,9 +127,6 @@ void TrialComparisonCertVerifierControll
   std::string serialized_report;
   if (!report.Serialize(&serialized_report))
     return;
-
-  CertificateReportingServiceFactory::GetForBrowserContext(profile_)->Send(
-      serialized_report);
 }
 
 // static
--- a/chrome/browser/password_manager/chrome_password_manager_client.cc
+++ b/chrome/browser/password_manager/chrome_password_manager_client.cc
@@ -25,7 +25,6 @@
 #include "chrome/browser/password_manager/touch_to_fill_controller.h"
 #include "chrome/browser/prerender/prerender_contents.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/chrome_password_protection_service.h"
 #include "chrome/browser/signin/identity_manager_factory.h"
 #include "chrome/browser/site_isolation/site_isolation_policy.h"
 #include "chrome/browser/sync/profile_sync_service_factory.h"
@@ -92,11 +91,11 @@
 #if BUILDFLAG(FULL_SAFE_BROWSING)
 #include "chrome/browser/safe_browsing/advanced_protection_status_manager.h"
 #include "chrome/browser/safe_browsing/advanced_protection_status_manager_factory.h"
+#endif
 #include "ui/base/clipboard/clipboard.h"
 #include "ui/events/keycodes/keyboard_codes.h"
 #include "services/service_manager/public/cpp/connector.h"
 #include "third_party/blink/public/mojom/clipboard/clipboard.mojom.h"
-#endif
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/preferences/preferences_launcher.h"
@@ -541,11 +540,10 @@ bool ChromePasswordManagerClient::IsIsol
 }
 
 #if defined(ON_FOCUS_PING_ENABLED) || \
-    defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)
+    (defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED) && defined(FULL_SAFE_BROWSING))
 safe_browsing::PasswordProtectionService*
 ChromePasswordManagerClient::GetPasswordProtectionService() const {
-  return safe_browsing::ChromePasswordProtectionService::
-      GetPasswordProtectionService(profile_);
+  return nullptr;
 }
 #endif
 
@@ -553,13 +551,6 @@ ChromePasswordManagerClient::GetPassword
 void ChromePasswordManagerClient::CheckSafeBrowsingReputation(
     const GURL& form_action,
     const GURL& frame_url) {
-  safe_browsing::PasswordProtectionService* pps =
-      GetPasswordProtectionService();
-  if (pps) {
-    pps->MaybeStartPasswordFieldOnFocusRequest(
-        web_contents(), web_contents()->GetLastCommittedURL(), form_action,
-        frame_url, pps->GetAccountInfo().hosted_domain);
-  }
 }
 #endif  // defined(ON_FOCUS_PING_ENABLED)
 
@@ -569,24 +560,11 @@ void ChromePasswordManagerClient::CheckP
     const std::string& username,
     const std::vector<std::string>& matching_domains,
     bool password_field_exists) {
-  safe_browsing::PasswordProtectionService* pps =
-      GetPasswordProtectionService();
-  if (!pps)
-    return;
-
-  pps->MaybeStartProtectedPasswordEntryRequest(
-      web_contents(), web_contents()->GetLastCommittedURL(), username,
-      password_type, matching_domains, password_field_exists);
 }
 #endif  // defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)
 
 #if defined(SYNC_PASSWORD_REUSE_WARNING_ENABLED)
 void ChromePasswordManagerClient::LogPasswordReuseDetectedEvent() {
-  safe_browsing::PasswordProtectionService* pps =
-      GetPasswordProtectionService();
-  if (pps) {
-    pps->MaybeLogPasswordReuseDetectedEvent(web_contents());
-  }
 }
 #endif  // defined(SYNC_PASSWORD_REUSE_WARNING_ENABLED)
 
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
@@ -252,7 +252,6 @@ void ChromeBrowserMainExtraPartsProfiles
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
   CaptivePortalServiceFactory::GetInstance();
 #endif
-  CertificateReportingServiceFactory::GetInstance();
   ChromeBrowsingDataRemoverDelegateFactory::GetInstance();
 #if defined(OS_CHROMEOS)
   chromeos::android_sms::AndroidSmsServiceFactory::GetInstance();
--- a/chrome/browser/profiles/profile_impl.cc
+++ b/chrome/browser/profiles/profile_impl.cc
@@ -602,17 +602,6 @@ void ProfileImpl::LoadPrefsForNormalStar
 
   mojo::PendingRemote<prefs::mojom::TrackedPreferenceValidationDelegate>
       pref_validation_delegate;
-  scoped_refptr<safe_browsing::SafeBrowsingService> safe_browsing_service(
-      g_browser_process->safe_browsing_service());
-  if (safe_browsing_service.get()) {
-    auto pref_validation_delegate_impl =
-        safe_browsing_service->CreatePreferenceValidationDelegate(this);
-    if (pref_validation_delegate_impl) {
-      mojo::MakeSelfOwnedReceiver(
-          std::move(pref_validation_delegate_impl),
-          pref_validation_delegate.InitWithNewPipeAndPassReceiver());
-    }
-  }
 
   prefs_ =
       CreatePrefService(pref_registry_, CreateExtensionPrefStore(this, false),
--- a/chrome/browser/profiles/profiles_state.cc
+++ b/chrome/browser/profiles/profiles_state.cc
@@ -220,9 +220,6 @@ void RemoveBrowsingDataForProfile(const 
   // The BrowsingDataRemover relies on many objects that aren't created in unit
   // tests. Previously this code would depend on content::ResourceDispatcherHost
   // but that's gone, so do a similar hack for now.
-  if (!g_browser_process->safe_browsing_service())
-    return;
-
   Profile* profile = g_browser_process->profile_manager()->GetProfileByPath(
       profile_path);
   if (!profile)
--- a/chrome/browser/safe_browsing/BUILD.gn
+++ b/chrome/browser/safe_browsing/BUILD.gn
@@ -7,6 +7,7 @@ import("//components/safe_browsing/build
 import("//extensions/buildflags/buildflags.gni")
 
 jumbo_static_library("safe_browsing") {
+  if(false) {
   sources = [
     "safe_browsing_controller_client.cc",
     "safe_browsing_controller_client.h",
@@ -62,6 +63,7 @@ jumbo_static_library("safe_browsing") {
     ]
     deps += [ "//extensions/browser" ]
   }
+  }
 
   if (safe_browsing_mode != 0) {
     # "Safe Browsing Basic" files used for safe browsing in full mode
--- a/chrome/browser/ssl/captive_portal_blocking_page.cc
+++ b/chrome/browser/ssl/captive_portal_blocking_page.cc
@@ -211,9 +211,6 @@ void CaptivePortalBlockingPage::Populate
   load_time_data->SetString("recurrentErrorParagraph", "");
   load_time_data->SetBoolean("show_recurrent_error_paragraph", false);
 
-  if (cert_report_helper())
-    cert_report_helper()->PopulateExtendedReportingOption(load_time_data);
-  else
     load_time_data->SetBoolean(security_interstitials::kDisplayCheckBox, false);
 }
 
@@ -229,8 +226,6 @@ void CaptivePortalBlockingPage::CommandR
   security_interstitials::SecurityInterstitialCommand cmd =
       static_cast<security_interstitials::SecurityInterstitialCommand>(
           command_num);
-  cert_report_helper()->HandleReportingCommands(cmd,
-                                                controller()->GetPrefService());
   switch (cmd) {
     case security_interstitials::CMD_OPEN_LOGIN:
       captive_portal::CaptivePortalMetrics::LogCaptivePortalBlockingPageEvent(
--- a/chrome/browser/ssl/cert_report_helper.cc
+++ b/chrome/browser/ssl/cert_report_helper.cc
@@ -181,8 +181,6 @@ void CertReportHelper::FinishCertCollect
     LOG(ERROR) << "Failed to serialize certificate report.";
     return;
   }
-
-  ssl_cert_reporter_->ReportInvalidCertificateChain(serialized_report);
 }
 
 bool CertReportHelper::ShouldShowCertificateReporterCheckbox() {
--- a/chrome/browser/ssl/security_state_tab_helper.cc
+++ b/chrome/browser/ssl/security_state_tab_helper.cc
@@ -231,92 +231,6 @@ bool SecurityStateTabHelper::UsedPolicyI
 
 security_state::MaliciousContentStatus
 SecurityStateTabHelper::GetMaliciousContentStatus() const {
-  content::NavigationEntry* entry =
-      web_contents()->GetController().GetVisibleEntry();
-  if (!entry)
-    return security_state::MALICIOUS_CONTENT_STATUS_NONE;
-  safe_browsing::SafeBrowsingService* sb_service =
-      g_browser_process->safe_browsing_service();
-  if (!sb_service)
-    return security_state::MALICIOUS_CONTENT_STATUS_NONE;
-  scoped_refptr<SafeBrowsingUIManager> sb_ui_manager = sb_service->ui_manager();
-  safe_browsing::SBThreatType threat_type;
-  if (sb_ui_manager->IsUrlWhitelistedOrPendingForWebContents(
-          entry->GetURL(), false, entry, web_contents(), false, &threat_type)) {
-    switch (threat_type) {
-      case safe_browsing::SB_THREAT_TYPE_UNUSED:
-      case safe_browsing::SB_THREAT_TYPE_SAFE:
-      case safe_browsing::SB_THREAT_TYPE_URL_PHISHING:
-      case safe_browsing::SB_THREAT_TYPE_URL_CLIENT_SIDE_PHISHING:
-        return security_state::MALICIOUS_CONTENT_STATUS_SOCIAL_ENGINEERING;
-      case safe_browsing::SB_THREAT_TYPE_URL_MALWARE:
-      case safe_browsing::SB_THREAT_TYPE_URL_CLIENT_SIDE_MALWARE:
-        return security_state::MALICIOUS_CONTENT_STATUS_MALWARE;
-      case safe_browsing::SB_THREAT_TYPE_URL_UNWANTED:
-        return security_state::MALICIOUS_CONTENT_STATUS_UNWANTED_SOFTWARE;
-      case safe_browsing::SB_THREAT_TYPE_SAVED_PASSWORD_REUSE:
-#if BUILDFLAG(FULL_SAFE_BROWSING)
-        return security_state::MALICIOUS_CONTENT_STATUS_SAVED_PASSWORD_REUSE;
-#endif
-      case safe_browsing::SB_THREAT_TYPE_SIGNED_IN_SYNC_PASSWORD_REUSE:
-#if BUILDFLAG(FULL_SAFE_BROWSING)
-        if (safe_browsing::ChromePasswordProtectionService::
-                ShouldShowPasswordReusePageInfoBubble(
-                    web_contents(), PasswordType::PRIMARY_ACCOUNT_PASSWORD)) {
-          return security_state::
-              MALICIOUS_CONTENT_STATUS_SIGNED_IN_SYNC_PASSWORD_REUSE;
-        }
-        // If user has already changed Gaia password, returns the regular
-        // social engineering content status.
-        return security_state::MALICIOUS_CONTENT_STATUS_SOCIAL_ENGINEERING;
-#endif
-      case safe_browsing::SB_THREAT_TYPE_SIGNED_IN_NON_SYNC_PASSWORD_REUSE:
-#if BUILDFLAG(FULL_SAFE_BROWSING)
-        if (safe_browsing::ChromePasswordProtectionService::
-                ShouldShowPasswordReusePageInfoBubble(
-                    web_contents(), PasswordType::OTHER_GAIA_PASSWORD)) {
-          return security_state::
-              MALICIOUS_CONTENT_STATUS_SIGNED_IN_NON_SYNC_PASSWORD_REUSE;
-        }
-        // If user has already changed Gaia password, returns the regular
-        // social engineering content status.
-        return security_state::MALICIOUS_CONTENT_STATUS_SOCIAL_ENGINEERING;
-#endif
-      case safe_browsing::SB_THREAT_TYPE_ENTERPRISE_PASSWORD_REUSE:
-#if BUILDFLAG(FULL_SAFE_BROWSING)
-        if (safe_browsing::ChromePasswordProtectionService::
-                ShouldShowPasswordReusePageInfoBubble(
-                    web_contents(), PasswordType::ENTERPRISE_PASSWORD)) {
-          return security_state::
-              MALICIOUS_CONTENT_STATUS_ENTERPRISE_PASSWORD_REUSE;
-        }
-        // If user has already changed Gaia password, returns the regular
-        // social engineering content status.
-        return security_state::MALICIOUS_CONTENT_STATUS_SOCIAL_ENGINEERING;
-#endif
-      case safe_browsing::SB_THREAT_TYPE_BILLING:
-        return security_state::MALICIOUS_CONTENT_STATUS_BILLING;
-      case safe_browsing::
-          DEPRECATED_SB_THREAT_TYPE_URL_PASSWORD_PROTECTION_PHISHING:
-      case safe_browsing::SB_THREAT_TYPE_URL_BINARY_MALWARE:
-      case safe_browsing::SB_THREAT_TYPE_EXTENSION:
-      case safe_browsing::SB_THREAT_TYPE_BLACKLISTED_RESOURCE:
-      case safe_browsing::SB_THREAT_TYPE_API_ABUSE:
-      case safe_browsing::SB_THREAT_TYPE_SUBRESOURCE_FILTER:
-      case safe_browsing::SB_THREAT_TYPE_CSD_WHITELIST:
-      case safe_browsing::SB_THREAT_TYPE_AD_SAMPLE:
-      case safe_browsing::SB_THREAT_TYPE_BLOCKED_AD_POPUP:
-      case safe_browsing::SB_THREAT_TYPE_BLOCKED_AD_REDIRECT:
-      case safe_browsing::SB_THREAT_TYPE_SUSPICIOUS_SITE:
-      case safe_browsing::SB_THREAT_TYPE_APK_DOWNLOAD:
-      case safe_browsing::SB_THREAT_TYPE_HIGH_CONFIDENCE_ALLOWLIST:
-        // These threat types are not currently associated with
-        // interstitials, and thus resources with these threat types are
-        // not ever whitelisted or pending whitelisting.
-        NOTREACHED();
-        break;
-    }
-  }
   return security_state::MALICIOUS_CONTENT_STATUS_NONE;
 }
 
--- a/chrome/browser/subresource_filter/chrome_subresource_filter_client.cc
+++ b/chrome/browser/subresource_filter/chrome_subresource_filter_client.cc
@@ -70,19 +70,6 @@ void ChromeSubresourceFilterClient::DidS
 void ChromeSubresourceFilterClient::MaybeAppendNavigationThrottles(
     content::NavigationHandle* navigation_handle,
     std::vector<std::unique_ptr<content::NavigationThrottle>>* throttles) {
-  safe_browsing::SafeBrowsingService* safe_browsing_service =
-      g_browser_process->safe_browsing_service();
-  if (navigation_handle->IsInMainFrame() && safe_browsing_service) {
-    throttles->push_back(
-        std::make_unique<subresource_filter::
-                             SubresourceFilterSafeBrowsingActivationThrottle>(
-            navigation_handle, this,
-            base::CreateSingleThreadTaskRunner({content::BrowserThread::IO}),
-            safe_browsing_service->database_manager()));
-  }
-
-  throttle_manager_->MaybeAppendNavigationThrottles(navigation_handle,
-                                                    throttles);
 }
 
 void ChromeSubresourceFilterClient::OnReloadRequested() {
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -341,15 +341,9 @@ jumbo_static_library("ui") {
     }
   }
 
-  if (safe_browsing_mode == 1) {
-    sources += [
-      "webui/reset_password/reset_password_ui.cc",
-      "webui/reset_password/reset_password_ui.h",
-    ]
-  }
 
   # TODO(crbug/925153): Remove this circular dependency.
-  allow_circular_includes_from = [ "//chrome/browser/safe_browsing" ]
+  allow_circular_includes_from = []
   defines = []
   libs = []
 
@@ -395,7 +389,6 @@ jumbo_static_library("ui") {
     "//chrome/browser/profiling_host",
     "//chrome/browser/resources/omnibox:resources",
     "//chrome/browser/resources/usb_internals:resources",
-    "//chrome/browser/safe_browsing",
     "//chrome/browser/ssl:proto",
     "//chrome/browser/ui/webui/bluetooth_internals",
     "//chrome/browser/ui/webui/downloads:mojo_bindings",
@@ -474,17 +467,6 @@ jumbo_static_library("ui") {
     "//components/rappor",
     "//components/renderer_context_menu",
     "//components/resources",
-    "//components/safe_browsing:csd_proto",
-    "//components/safe_browsing:features",
-    "//components/safe_browsing/common",
-    "//components/safe_browsing/common:safe_browsing_prefs",
-    "//components/safe_browsing/db:database_manager",
-    "//components/safe_browsing/db:util",
-    "//components/safe_browsing/password_protection",
-    "//components/safe_browsing/password_protection:password_protection_metrics_util",
-    "//components/safe_browsing/triggers:ad_popup_trigger",
-    "//components/safe_browsing/triggers:ad_redirect_trigger",
-    "//components/safe_browsing/web_ui",
     "//components/search",
     "//components/search_engines",
     "//components/security_interstitials/content:security_interstitial_page",
@@ -2700,7 +2682,6 @@ jumbo_static_library("ui") {
       "views/device_chooser_content_view.h",
       "views/devtools_process_observer.cc",
       "views/devtools_process_observer.h",
-      "views/download/download_danger_prompt_views.cc",
       "views/download/download_in_progress_dialog_view.cc",
       "views/download/download_in_progress_dialog_view.h",
       "views/download/download_item_view.cc",
@@ -3983,15 +3964,6 @@ jumbo_static_library("ui") {
     }
   }
 
-  if (safe_browsing_mode == 1) {
-    deps += [
-      "//chrome/browser/ui/webui/reset_password:mojo_bindings",
-      "//chrome/common/safe_browsing:proto",
-      "//components/safe_browsing:csd_proto",
-      "//components/safe_browsing/password_protection:password_protection_metrics_util",
-    ]
-  }
-
   if (use_dbus) {
     deps += [ "//dbus" ]
   }
--- a/chrome/browser/ui/blocked_content/popup_blocker.cc
+++ b/chrome/browser/ui/blocked_content/popup_blocker.cc
@@ -70,28 +70,6 @@ PopupBlockType ShouldBlockPopup(content:
   return PopupBlockType::kNotBlocked;
 }
 
-// Tries to get the opener from either the |params| or |open_url_params|,
-// otherwise uses the focused frame from |web_contents| as a proxy.
-content::RenderFrameHost* GetSourceFrameForPopup(
-    NavigateParams* params,
-    const content::OpenURLParams* open_url_params,
-    content::WebContents* web_contents) {
-  if (params->opener)
-    return params->opener;
-  // Make sure the source render frame host is alive before we attempt to
-  // retrieve it from |open_url_params|.
-  if (open_url_params) {
-    content::RenderFrameHost* source = content::RenderFrameHost::FromID(
-        open_url_params->source_render_frame_id,
-        open_url_params->source_render_process_id);
-    if (source)
-      return source;
-  }
-  // The focused frame is not always the frame initiating the popup navigation
-  // and is used as a fallback in case opener information is not available.
-  return web_contents->GetFocusedFrame();
-}
-
 }  // namespace
 
 bool ConsiderForPopupBlocking(WindowOpenDisposition disposition) {
@@ -122,11 +100,6 @@ bool MaybeBlockPopup(content::WebContent
     return false;
 
   popup_blocker->AddBlockedPopup(params, window_features, block_type);
-  auto* trigger = safe_browsing::AdPopupTrigger::FromWebContents(web_contents);
-  if (trigger) {
-    content::RenderFrameHost* source_frame =
-        GetSourceFrameForPopup(params, open_url_params, web_contents);
-    trigger->PopupWasBlocked(source_frame);
-  }
+
   return true;
 }
--- a/chrome/browser/ui/browser.cc
+++ b/chrome/browser/ui/browser.cc
@@ -1327,10 +1327,6 @@ void Browser::OnDidBlockNavigation(conte
       framebust_helper->AddBlockedUrl(blocked_url, base::BindOnce(on_click));
     }
   }
-  if (auto* trigger =
-          safe_browsing::AdRedirectTrigger::FromWebContents(web_contents)) {
-    trigger->OnDidBlockNavigation(initiator_url);
-  }
 }
 
 content::PictureInPictureResult Browser::EnterPictureInPicture(
--- a/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
+++ b/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
@@ -6,64 +6,16 @@
 
 #include "base/strings/utf_string_conversions.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/cloud_content_scanning/deep_scanning_dialog_delegate.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/browser/web_contents_view_delegate.h"
 #include "content/public/common/drop_data.h"
 
 namespace {
 
-void DeepScanCompletionCallback(
-    content::WebContentsViewDelegate::DropCompletionCallback callback,
-    const safe_browsing::DeepScanningDialogDelegate::Data& data,
-    const safe_browsing::DeepScanningDialogDelegate::Result& result) {
-  // If any result is negative, block the drop.
-  const auto all_true_fn = [](const auto& vec) {
-    return std::all_of(vec.cbegin(), vec.cend(), [](bool b) { return b; });
-  };
-  bool all_true =
-      all_true_fn(result.text_results) && all_true_fn(result.paths_results);
-
-  std::move(callback).Run(
-      all_true
-          ? content::WebContentsViewDelegate::DropCompletionResult::kContinue
-          : content::WebContentsViewDelegate::DropCompletionResult::kAbort);
-}
-
 }  // namespace
 
 void HandleOnPerformDrop(
     content::WebContents* web_contents,
     const content::DropData& drop_data,
     content::WebContentsViewDelegate::DropCompletionCallback callback) {
-  safe_browsing::DeepScanningDialogDelegate::Data data;
-  Profile* profile =
-      Profile::FromBrowserContext(web_contents->GetBrowserContext());
-  if (!safe_browsing::DeepScanningDialogDelegate::IsEnabled(
-          profile, web_contents->GetLastCommittedURL(), &data)) {
-    std::move(callback).Run(
-        content::WebContentsViewDelegate::DropCompletionResult::kContinue);
-    return;
-  }
-
-  // Collect the data that needs to be scanned.
-  if (!drop_data.url_title.empty())
-    data.text.push_back(drop_data.url_title);
-  if (!drop_data.text.is_null())
-    data.text.push_back(drop_data.text.string());
-  if (!drop_data.html.is_null())
-    data.text.push_back(drop_data.html.string());
-  if (!drop_data.file_contents.empty())
-    data.text.push_back(base::UTF8ToUTF16(drop_data.file_contents));
-
-  for (const auto& file : drop_data.filenames)
-    data.paths.push_back(file.path);
-
-  // TODO(crbug.com/1008040): how to handle drop_data.file_system_files?
-  // These are URLs that use the filesystem: schema.  Support for this API
-  // is unclear.
-
-  safe_browsing::DeepScanningDialogDelegate::ShowForWebContents(
-      web_contents, std::move(data),
-      base::BindOnce(&DeepScanCompletionCallback, std::move(callback)));
 }
--- a/chrome/browser/ui/tab_helpers.cc
+++ b/chrome/browser/ui/tab_helpers.cc
@@ -248,10 +248,6 @@ void TabHelpers::AttachTabHelpers(WebCon
   PreviewsUITabHelper::CreateForWebContents(web_contents);
   RecentlyAudibleHelper::CreateForWebContents(web_contents);
   ResourceLoadingHintsWebContentsObserver::CreateForWebContents(web_contents);
-  safe_browsing::SafeBrowsingNavigationObserver::MaybeCreateForWebContents(
-      web_contents);
-  safe_browsing::TriggerCreator::MaybeCreateTriggersForWebContents(
-      profile, web_contents);
   safety_tips::ReputationWebContentsObserver::CreateForWebContents(
       web_contents);
   SearchEngineTabHelper::CreateForWebContents(web_contents);
@@ -304,7 +300,6 @@ void TabHelpers::AttachTabHelpers(WebCon
       web_contents, std::make_unique<ChromePDFWebContentsHelperClient>());
   PluginObserver::CreateForWebContents(web_contents);
   SadTabHelper::CreateForWebContents(web_contents);
-  safe_browsing::SafeBrowsingTabObserver::CreateForWebContents(web_contents);
   SearchTabHelper::CreateForWebContents(web_contents);
   TabDialogs::CreateForWebContents(web_contents);
   if (base::FeatureList::IsEnabled(features::kTabHoverCardImages) ||
--- a/chrome/browser/ui/views/download/download_item_view.cc
+++ b/chrome/browser/ui/views/download/download_item_view.cc
@@ -29,24 +29,17 @@
 #include "chrome/browser/download/download_stats.h"
 #include "chrome/browser/download/drag_download_item.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/advanced_protection_status_manager.h"
-#include "chrome/browser/safe_browsing/advanced_protection_status_manager_factory.h"
-#include "chrome/browser/safe_browsing/download_protection/download_feedback_service.h"
-#include "chrome/browser/safe_browsing/download_protection/download_protection_service.h"
-#include "chrome/browser/safe_browsing/safe_browsing_service.h"
 #include "chrome/browser/themes/theme_properties.h"
 #include "chrome/browser/ui/tab_modal_confirm_dialog.h"
 #include "chrome/browser/ui/views/download/download_shelf_context_menu_view.h"
 #include "chrome/browser/ui/views/download/download_shelf_view.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
-#include "chrome/browser/ui/views/safe_browsing/deep_scanning_modal_dialog.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/grit/generated_resources.h"
 #include "components/download/public/common/download_danger_type.h"
 #include "components/download/public/common/download_item.h"
 #include "components/prefs/pref_service.h"
 #include "components/safe_browsing/buildflags.h"
-#include "components/safe_browsing/common/safe_browsing_prefs.h"
 #include "components/url_formatter/elide_url.h"
 #include "components/vector_icons/vector_icons.h"
 #include "content/public/browser/download_item_utils.h"
@@ -304,9 +297,6 @@ void DownloadItemView::OnDownloadUpdated
       TransitionToWarningDialog();
   } else if (is_danger_type_async_scanning &&
              model_->GetState() != DownloadItem::CANCELLED) {
-    if (!IsShowingDeepScanning())
-      TransitionToDeepScanningDialog();
-
     if (should_open_while_scanning_ &&
         model_->GetState() == DownloadItem::COMPLETE) {
       should_open_while_scanning_ = false;
@@ -622,18 +612,6 @@ void DownloadItemView::ButtonPressed(vie
     return;
   }
 
-  if (IsShowingDeepScanning() && sender == open_button_) {
-    content::WebContents* current_web_contents =
-        shelf_->browser()->tab_strip_model()->GetActiveWebContents();
-    open_now_modal_dialog_ = TabModalConfirmDialog::Create(
-        std::make_unique<safe_browsing::DeepScanningModalDialog>(
-            current_web_contents,
-            base::BindOnce(&DownloadItemView::OpenDownloadDuringAsyncScanning,
-                           weak_ptr_factory_.GetWeakPtr())),
-        current_web_contents);
-    return;
-  }
-
   if (sender == dropdown_button_) {
     // TODO(estade): this is copied from ToolbarActionView but should be shared
     // one way or another.
@@ -1000,14 +978,6 @@ void DownloadItemView::ShowWarningDialog
 gfx::ImageSkia DownloadItemView::GetWarningIcon() {
   switch (model_->GetDangerType()) {
     case download::DOWNLOAD_DANGER_TYPE_UNCOMMON_CONTENT:
-      if (safe_browsing::AdvancedProtectionStatusManagerFactory::GetForProfile(
-              model()->profile())
-              ->RequestsAdvancedProtectionVerdicts()) {
-        return gfx::CreateVectorIcon(
-            vector_icons::kErrorIcon, kErrorIconSize,
-            GetNativeTheme()->GetSystemColor(
-                ui::NativeTheme::kColorId_AlertSeverityMedium));
-      }
       FALLTHROUGH;
 
     case download::DOWNLOAD_DANGER_TYPE_DANGEROUS_URL:
@@ -1044,35 +1014,6 @@ gfx::ImageSkia DownloadItemView::GetWarn
 }
 
 void DownloadItemView::ShowDeepScanningDialog() {
-  DCHECK_EQ(mode_, NORMAL_MODE);
-  SetMode(DEEP_SCANNING_MODE);
-
-  base::string16 elided_filename =
-      gfx::ElideFilename(model_->GetFileNameToReportUser(), font_list_,
-                         kTextWidth, gfx::Typesetter::BROWSER);
-  base::string16 deep_scanning_text = l10n_util::GetStringFUTF16(
-      IDS_PROMPT_DEEP_SCANNING_DOWNLOAD, elided_filename);
-  auto deep_scanning_label = std::make_unique<views::Label>(deep_scanning_text);
-  deep_scanning_label->SetMultiLine(true);
-  deep_scanning_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
-  deep_scanning_label->SetAutoColorReadabilityEnabled(false);
-  deep_scanning_label_ = AddChildView(std::move(deep_scanning_label));
-  deep_scanning_label_->SetSize(AdjustTextAndGetSize(deep_scanning_label_));
-
-  int delay_delivery = g_browser_process->local_state()->GetInteger(
-      prefs::kDelayDeliveryUntilVerdict);
-  if (delay_delivery != safe_browsing::DELAY_DOWNLOADS &&
-      delay_delivery != safe_browsing::DELAY_UPLOADS_AND_DOWNLOADS) {
-    auto open_now_button = views::MdTextButton::Create(
-        this, l10n_util::GetStringUTF16(IDS_OPEN_DOWNLOAD_NOW));
-    open_now_button_ = AddChildView(std::move(open_now_button));
-    open_button_->SetEnabled(true);
-  } else {
-    open_button_->SetEnabled(false);
-  }
-
-  file_name_label_->SetVisible(false);
-  status_label_->SetVisible(false);
 }
 
 void DownloadItemView::ClearDeepScanningDialog() {
@@ -1357,6 +1298,5 @@ base::string16 DownloadItemView::ElidedF
 }
 
 void DownloadItemView::OpenDownloadDuringAsyncScanning() {
-  model_->CompleteSafeBrowsingScan();
   should_open_while_scanning_ = true;
 }
--- a/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc
+++ b/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc
@@ -147,9 +147,7 @@ PasswordReuseModalWarningDialog::Passwor
     service_->AddObserver(this);
 
   views::Label* message_body_label = CreateMessageBodyLabel(
-      service_
-          ? service_->GetWarningDetailText(password_type)
-          : l10n_util::GetStringUTF16(IDS_PAGE_INFO_CHANGE_PASSWORD_DETAILS));
+      l10n_util::GetStringUTF16(IDS_PAGE_INFO_CHANGE_PASSWORD_DETAILS));
 
   if (password_type.account_type() ==
       ReusedPasswordAccountType::SAVED_PASSWORD) {
--- a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
+++ b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
@@ -78,8 +78,6 @@
 #include "components/nacl/common/buildflags.h"
 #include "components/prefs/pref_service.h"
 #include "components/safe_browsing/buildflags.h"
-#include "components/safe_browsing/web_ui/constants.h"
-#include "components/safe_browsing/web_ui/safe_browsing_ui.h"
 #include "components/security_interstitials/content/connection_help_ui.h"
 #include "components/security_interstitials/content/urls.h"
 #include "content/public/browser/web_contents.h"
@@ -390,8 +388,6 @@ WebUIFactoryFunction GetWebUIFactoryFunc
     return &NewWebUI<PredictorsUI>;
   if (url.host_piece() == chrome::kChromeUIQuotaInternalsHost)
     return &NewWebUI<QuotaInternalsUI>;
-  if (url.host_piece() == safe_browsing::kChromeUISafeBrowsingHost)
-    return &NewWebUI<safe_browsing::SafeBrowsingUI>;
   if (url.host_piece() == chrome::kChromeUISignInInternalsHost)
     return &NewWebUI<SignInInternalsUI>;
   if (url.host_piece() == chrome::kChromeUISuggestionsHost)
--- a/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc
+++ b/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc
@@ -23,7 +23,6 @@
 #include "base/threading/thread.h"
 #include "base/values.h"
 #include "chrome/browser/browser_process.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/download/download_history.h"
 #include "chrome/browser/download/download_item_model.h"
 #include "chrome/browser/download/download_prefs.h"
@@ -167,9 +166,6 @@ void DownloadsDOMHandler::SaveDangerousR
   }
 
   CountDownloadsDOMEvents(DOWNLOADS_DOM_EVENT_SAVE_DANGEROUS);
-  download::DownloadItem* file = GetDownloadByStringId(id);
-  if (file)
-    ShowDangerPrompt(file);
 }
 
 void DownloadsDOMHandler::DiscardDangerous(const std::string& id) {
@@ -312,12 +308,6 @@ void DownloadsDOMHandler::RemoveDownload
   IdSet ids;
 
   for (auto* download : to_remove) {
-    if (download->IsDangerous()) {
-      // Don't allow users to revive dangerous downloads; just nuke 'em.
-      download->Remove();
-      continue;
-    }
-
     DownloadItemModel item_model(download);
     if (!item_model.ShouldShowInShelf() ||
         download->GetState() == download::DownloadItem::IN_PROGRESS) {
@@ -374,32 +364,6 @@ void DownloadsDOMHandler::FinalizeRemova
   }
 }
 
-void DownloadsDOMHandler::ShowDangerPrompt(
-    download::DownloadItem* dangerous_item) {
-  DownloadDangerPrompt* danger_prompt = DownloadDangerPrompt::Create(
-      dangerous_item, GetWebUIWebContents(), false,
-      base::Bind(&DownloadsDOMHandler::DangerPromptDone,
-                 weak_ptr_factory_.GetWeakPtr(), dangerous_item->GetId()));
-  // danger_prompt will delete itself.
-  DCHECK(danger_prompt);
-}
-
-void DownloadsDOMHandler::DangerPromptDone(
-    int download_id,
-    DownloadDangerPrompt::Action action) {
-  if (action != DownloadDangerPrompt::ACCEPT)
-    return;
-  download::DownloadItem* item = NULL;
-  if (GetMainNotifierManager())
-    item = GetMainNotifierManager()->GetDownload(download_id);
-  if (!item && GetOriginalNotifierManager())
-    item = GetOriginalNotifierManager()->GetDownload(download_id);
-  if (!item || item->IsDone())
-    return;
-  CountDownloadsDOMEvents(DOWNLOADS_DOM_EVENT_SAVE_DANGEROUS);
-  item->ValidateDangerousDownload();
-}
-
 bool DownloadsDOMHandler::IsDeletingHistoryAllowed() {
   content::DownloadManager* manager = GetMainNotifierManager();
   return manager &&
--- a/chrome/browser/ui/webui/downloads/downloads_dom_handler.h
+++ b/chrome/browser/ui/webui/downloads/downloads_dom_handler.h
@@ -12,7 +12,6 @@
 
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/ui/webui/downloads/downloads.mojom.h"
 #include "chrome/browser/ui/webui/downloads/downloads_list_tracker.h"
 #include "content/public/browser/web_contents_observer.h"
@@ -88,18 +87,6 @@ class DownloadsDOMHandler : public conte
   // null-checking |original_notifier_|.
   content::DownloadManager* GetOriginalNotifierManager() const;
 
-  // Displays a native prompt asking the user for confirmation after accepting
-  // the dangerous download specified by |dangerous|. The function returns
-  // immediately, and will invoke DangerPromptAccepted() asynchronously if the
-  // user accepts the dangerous download. The native prompt will observe
-  // |dangerous| until either the dialog is dismissed or |dangerous| is no
-  // longer an in-progress dangerous download.
-  virtual void ShowDangerPrompt(download::DownloadItem* dangerous);
-
-  // Conveys danger acceptance from the DownloadDangerPrompt to the
-  // DownloadItem.
-  void DangerPromptDone(int download_id, DownloadDangerPrompt::Action action);
-
   // Returns true if the records of any downloaded items are allowed (and able)
   // to be deleted.
   bool IsDeletingHistoryAllowed();
--- a/chrome/browser/ui/webui/interstitials/interstitial_ui.cc
+++ b/chrome/browser/ui/webui/interstitials/interstitial_ui.cc
@@ -272,117 +272,6 @@ LookalikeUrlInterstitialPage* CreateLook
                                                      safe_url));
 }
 
-safe_browsing::SafeBrowsingBlockingPage* CreateSafeBrowsingBlockingPage(
-    content::WebContents* web_contents) {
-  safe_browsing::SBThreatType threat_type =
-      safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-  GURL request_url("http://example.com");
-  std::string url_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(),
-                                 "url",
-                                 &url_param)) {
-    if (GURL(url_param).is_valid()) {
-      request_url = GURL(url_param);
-    }
-  }
-  GURL main_frame_url(request_url);
-  // TODO(mattm): add flag to change main_frame_url or add dedicated flag to
-  // test subresource interstitials.
-  std::string type_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(),
-                                 "type",
-                                 &type_param)) {
-    if (type_param == "malware") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-    } else if (type_param == "phishing") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_PHISHING;
-    } else if (type_param == "unwanted") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_UNWANTED;
-    } else if (type_param == "clientside_malware") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_CLIENT_SIDE_MALWARE;
-    } else if (type_param == "clientside_phishing") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_CLIENT_SIDE_PHISHING;
-    } else if (type_param == "billing") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_BILLING;
-    }
-  }
-  safe_browsing::SafeBrowsingBlockingPage::UnsafeResource resource;
-  resource.url = request_url;
-  resource.is_subresource = request_url != main_frame_url;
-  resource.is_subframe = false;
-  resource.threat_type = threat_type;
-  resource.web_contents_getter =
-      security_interstitials::UnsafeResource::GetWebContentsGetter(
-          web_contents->GetMainFrame()->GetProcess()->GetID(),
-          web_contents->GetMainFrame()->GetRoutingID());
-  resource.threat_source = g_browser_process->safe_browsing_service()
-                               ->database_manager()
-                               ->GetThreatSource();
-
-  // Normally safebrowsing interstitial types which block the main page load
-  // (SB_THREAT_TYPE_URL_MALWARE, SB_THREAT_TYPE_URL_PHISHING, and
-  // SB_THREAT_TYPE_URL_UNWANTED on main-frame loads) would expect there to be a
-  // pending navigation when the SafeBrowsingBlockingPage is created. This demo
-  // creates a SafeBrowsingBlockingPage but does not actually show a real
-  // interstitial. Instead it extracts the html and displays it manually, so the
-  // parts which depend on the NavigationEntry are not hit.
-  return safe_browsing::SafeBrowsingBlockingPage::CreateBlockingPage(
-      g_browser_process->safe_browsing_service()->ui_manager().get(),
-      web_contents, main_frame_url, resource);
-}
-
-TestSafeBrowsingBlockingPageQuiet* CreateSafeBrowsingQuietBlockingPage(
-    content::WebContents* web_contents) {
-  safe_browsing::SBThreatType threat_type =
-      safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-  GURL request_url("http://example.com");
-  std::string url_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(), "url", &url_param)) {
-    if (GURL(url_param).is_valid())
-      request_url = GURL(url_param);
-  }
-  GURL main_frame_url(request_url);
-  std::string type_param;
-  bool is_giant_webview = false;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(), "type", &type_param)) {
-    if (type_param == "malware") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-    } else if (type_param == "phishing") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_PHISHING;
-    } else if (type_param == "unwanted") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_UNWANTED;
-    } else if (type_param == "billing") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_BILLING;
-    } else if (type_param == "giant") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-      is_giant_webview = true;
-    }
-  }
-  safe_browsing::SafeBrowsingBlockingPage::UnsafeResource resource;
-  resource.url = request_url;
-  resource.is_subresource = request_url != main_frame_url;
-  resource.is_subframe = false;
-  resource.threat_type = threat_type;
-  resource.web_contents_getter =
-      security_interstitials::UnsafeResource::GetWebContentsGetter(
-          web_contents->GetMainFrame()->GetProcess()->GetID(),
-          web_contents->GetMainFrame()->GetRoutingID());
-  resource.threat_source = g_browser_process->safe_browsing_service()
-                               ->database_manager()
-                               ->GetThreatSource();
-
-  // Normally safebrowsing interstitial types which block the main page load
-  // (SB_THREAT_TYPE_URL_MALWARE, SB_THREAT_TYPE_URL_PHISHING, and
-  // SB_THREAT_TYPE_URL_UNWANTED on main-frame loads) would expect there to be a
-  // pending navigation when the SafeBrowsingBlockingPage is created. This demo
-  // creates a SafeBrowsingBlockingPage but does not actually show a real
-  // interstitial. Instead it extracts the html and displays it manually, so the
-  // parts which depend on the NavigationEntry are not hit.
-  return TestSafeBrowsingBlockingPageQuiet::CreateBlockingPage(
-      g_browser_process->safe_browsing_service()->ui_manager().get(),
-      web_contents, main_frame_url, resource, is_giant_webview);
-}
-
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
 CaptivePortalBlockingPage* CreateCaptivePortalBlockingPage(
     content::WebContents* web_contents) {
@@ -488,8 +377,6 @@ void InterstitialHTMLSource::StartDataRe
     interstitial_delegate.reset(CreateSSLBlockingPage(web_contents));
   } else if (path_without_query == "/mitm-software-ssl") {
     interstitial_delegate.reset(CreateMITMSoftwareBlockingPage(web_contents));
-  } else if (path_without_query == "/safebrowsing") {
-    interstitial_delegate.reset(CreateSafeBrowsingBlockingPage(web_contents));
   } else if (path_without_query == "/clock") {
     interstitial_delegate.reset(CreateBadClockBlockingPage(web_contents));
   } else if (path_without_query == "/lookalike") {
@@ -503,11 +390,7 @@ void InterstitialHTMLSource::StartDataRe
         CreateOriginPolicyInterstitialPage(web_contents));
   }
 
-  if (path_without_query == "/quietsafebrowsing") {
-    TestSafeBrowsingBlockingPageQuiet* blocking_page =
-        CreateSafeBrowsingQuietBlockingPage(web_contents);
-    interstitial_delegate.reset(blocking_page);
-    html = blocking_page->GetHTML();
+  if (0) {
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
   } else if (path_without_query == "/supervised_user") {
     html = GetSupervisedUserInterstitialHTML(path);
--- a/chrome/browser/ui/webui/settings/change_password_handler.cc
+++ b/chrome/browser/ui/webui/settings/change_password_handler.cc
@@ -58,24 +58,10 @@ void ChangePasswordHandler::HandleInitia
 }
 
 void ChangePasswordHandler::HandleChangePassword(const base::ListValue* args) {
-  service_->OnUserAction(
-      web_ui()->GetWebContents(),
-      service_->reused_password_account_type_for_last_shown_warning(),
-      RequestOutcome::UNKNOWN,
-      LoginReputationClientResponse::VERDICT_TYPE_UNSPECIFIED, "unused_token",
-      safe_browsing::WarningUIType::CHROME_SETTINGS,
-      safe_browsing::WarningAction::CHANGE_PASSWORD);
+
 }
 
 void ChangePasswordHandler::UpdateChangePasswordCardVisibility() {
-  FireWebUIListener(
-      "change-password-visibility",
-      base::Value(
-          service_->IsWarningEnabled(
-              service_
-                  ->reused_password_account_type_for_last_shown_warning()) &&
-          safe_browsing::ChromePasswordProtectionService::
-              ShouldShowChangePasswordSettingUI(profile_)));
 }
 
 }  // namespace settings
--- a/chrome/renderer/chrome_content_renderer_client.cc
+++ b/chrome/renderer/chrome_content_renderer_client.cc
@@ -86,7 +86,6 @@
 #include "components/page_load_metrics/renderer/metrics_render_frame_observer.h"
 #include "components/pdf/renderer/pepper_pdf_host.h"
 #include "components/safe_browsing/buildflags.h"
-#include "components/safe_browsing/renderer/threat_dom_details.h"
 #include "components/spellcheck/spellcheck_buildflags.h"
 #include "components/startup_metric_utils/common/startup_metric.mojom.h"
 #include "components/subresource_filter/content/renderer/subresource_filter_agent.h"
--- a/components/safe_browsing/common/safe_browsing.mojom
+++ b/components/safe_browsing/common/safe_browsing.mojom
@@ -127,7 +127,6 @@ enum PhishingDetectorResult {
   INVALID_SCORE = 4,
 };
 
-[EnableIf=full_safe_browsing]
 interface PhishingDetector {
   // Tells the renderer to begin phishing detection for the given toplevel URL
   // which it has started loading. Returns the serialized request proto and a
--- a/components/safe_browsing/features.cc
+++ b/components/safe_browsing/features.cc
@@ -87,7 +87,7 @@ constexpr base::FeatureParam<bool> kShou
     &kPasswordProtectionForSignedInUsers, "DeprecateOldProto", false};
 
 const base::Feature kSuspiciousSiteTriggerQuotaFeature{
-    "SafeBrowsingSuspiciousSiteTriggerQuota", base::FEATURE_ENABLED_BY_DEFAULT};
+    "SafeBrowsingSuspiciousSiteTriggerQuota", base::FEATURE_DISABLED_BY_DEFAULT};
 
 const base::Feature kThreatDomDetailsTagAndAttributeFeature{
     "ThreatDomDetailsTagAttributes", base::FEATURE_DISABLED_BY_DEFAULT};
--- a/chrome/common/safe_browsing/BUILD.gn
+++ b/chrome/common/safe_browsing/BUILD.gn
@@ -78,41 +78,6 @@ if (safe_browsing_mode == 1) {
     ]
   }
 
-  source_set("rar_analyzer") {
-    sources = [
-      "rar_analyzer.cc",
-      "rar_analyzer.h",
-    ]
-
-    deps = [
-      ":archive_analyzer_results",
-      ":download_type_util",
-      ":file_type_policies",
-      "//base",
-      "//base:i18n",
-      "//components/safe_browsing:features",
-      "//third_party/unrar:unrar",
-    ]
-
-    defines = [
-      "_FILE_OFFSET_BITS=64",
-      "LARGEFILE_SOURCE",
-      "RAR_SMP",
-      "SILENT",
-
-      # The following is set to disable certain macro definitions in the unrar
-      # source code.
-      "CHROMIUM_UNRAR",
-
-      # Disables exceptions in unrar, replaces them with process termination.
-      "UNRAR_NO_EXCEPTIONS",
-    ]
-
-    public_deps = [
-      "//components/safe_browsing:csd_proto",
-    ]
-  }
-
   source_set("disk_image_type_sniffer_mac") {
     sources = [
       "disk_image_type_sniffer_mac.cc",
@@ -185,7 +150,6 @@ source_set("safe_browsing") {
       ":archive_analyzer_results",
       ":binary_feature_extractor",
       ":download_type_util",
-      ":rar_analyzer",
       "//components/safe_browsing:features",
     ]
 
--- a/chrome/services/file_util/safe_archive_analyzer.cc
+++ b/chrome/services/file_util/safe_archive_analyzer.cc
@@ -7,7 +7,6 @@
 #include "base/macros.h"
 #include "build/build_config.h"
 #include "chrome/common/safe_browsing/archive_analyzer_results.h"
-#include "chrome/common/safe_browsing/rar_analyzer.h"
 #include "chrome/common/safe_browsing/zip_analyzer.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
 
@@ -48,8 +47,7 @@ void SafeArchiveAnalyzer::AnalyzeRarFile
                                          AnalyzeRarFileCallback callback) {
   DCHECK(rar_file.IsValid());
 
+  LOG(FATAL) << "AnalyzeRarFile is disabled in this build";
   safe_browsing::ArchiveAnalyzerResults results;
-  safe_browsing::rar_analyzer::AnalyzeRarFile(
-      std::move(rar_file), std::move(temporary_file), &results);
   std::move(callback).Run(results);
 }
--- a/chrome/browser/safe_browsing/download_protection/file_analyzer.cc
+++ b/chrome/browser/safe_browsing/download_protection/file_analyzer.cc
@@ -92,7 +92,7 @@ void FileAnalyzer::Start(const base::Fil
   if (inspection_type == DownloadFileType::ZIP) {
     StartExtractZipFeatures();
   } else if (inspection_type == DownloadFileType::RAR) {
-    StartExtractRarFeatures();
+    LOG(WARNING) << "Safebrowser inspection of rar files is disabled in this build";
 #if defined(OS_MACOSX)
   } else if (inspection_type == DownloadFileType::DMG) {
     StartExtractDmgFeatures();
--- a/chrome/browser/resources/settings/privacy_page/personalization_options.html
+++ b/chrome/browser/resources/settings/privacy_page/personalization_options.html
@@ -39,15 +39,6 @@
         label="$i18n{linkDoctorPref}"
         sub-label="$i18n{linkDoctorPrefDesc}">
     </settings-toggle-button>
-    <settings-toggle-button pref="{{prefs.safebrowsing.enabled}}"
-        label="$i18n{safeBrowsingEnableProtection}"
-        sub-label="$i18n{safeBrowsingEnableProtectionDesc}">
-    </settings-toggle-button>
-    <settings-toggle-button
-        pref="{{prefs.safebrowsing.scout_reporting_enabled}}"
-        label="$i18n{safeBrowsingEnableExtendedReporting}"
-        sub-label="$i18n{safeBrowsingEnableExtendedReportingDesc}">
-    </settings-toggle-button>
 <if expr="_google_chrome">
 <if expr="chromeos">
     <settings-toggle-button pref="{{prefs.cros.metrics.reportingEnabled}}"
